# Generated from DeclSpecLanguage.g4 by ANTLR 4.5.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"%\u008a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3")
        buf.write(u"\2\3\2\3\2\3\3\3\3\3\3\3\3\7\3,\n\3\f\3\16\3/\13\3\3")
        buf.write(u"\4\5\4\62\n\4\3\4\3\4\3\5\3\5\5\58\n\5\3\6\3\6\3\6\3")
        buf.write(u"\6\5\6>\n\6\3\7\3\7\3\7\3\7\7\7D\n\7\f\7\16\7G\13\7\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\5\bd\n\b\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\5\nn\n\n")
        buf.write(u"\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5")
        buf.write(u"\13z\n\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3")
        buf.write(u"\20\3\21\3\21\3\22\3\22\3\22\2\2\23\2\4\6\b\n\f\16\20")
        buf.write(u"\22\24\26\30\32\34\36 \"\2\b\3\2\22\23\4\2\n\n !\4\2")
        buf.write(u"\13\f\20\21\3\2\34\36\3\2\26\33\3\2\16\17\u0088\2$\3")
        buf.write(u"\2\2\2\4\'\3\2\2\2\6\61\3\2\2\2\b\67\3\2\2\2\n9\3\2\2")
        buf.write(u"\2\f?\3\2\2\2\16c\3\2\2\2\20e\3\2\2\2\22m\3\2\2\2\24")
        buf.write(u"y\3\2\2\2\26{\3\2\2\2\30}\3\2\2\2\32\177\3\2\2\2\34\u0081")
        buf.write(u"\3\2\2\2\36\u0083\3\2\2\2 \u0085\3\2\2\2\"\u0087\3\2")
        buf.write(u"\2\2$%\5\4\3\2%&\7\2\2\3&\3\3\2\2\2\'-\5\6\4\2()\5\30")
        buf.write(u"\r\2)*\5\6\4\2*,\3\2\2\2+(\3\2\2\2,/\3\2\2\2-+\3\2\2")
        buf.write(u"\2-.\3\2\2\2.\5\3\2\2\2/-\3\2\2\2\60\62\5 \21\2\61\60")
        buf.write(u"\3\2\2\2\61\62\3\2\2\2\62\63\3\2\2\2\63\64\5\b\5\2\64")
        buf.write(u"\7\3\2\2\2\658\5\"\22\2\668\5\n\6\2\67\65\3\2\2\2\67")
        buf.write(u"\66\3\2\2\28\t\3\2\2\29=\5\f\7\2:;\5\36\20\2;<\5\f\7")
        buf.write(u"\2<>\3\2\2\2=:\3\2\2\2=>\3\2\2\2>\13\3\2\2\2?E\5\16\b")
        buf.write(u"\2@A\5\32\16\2AB\5\16\b\2BD\3\2\2\2C@\3\2\2\2DG\3\2\2")
        buf.write(u"\2EC\3\2\2\2EF\3\2\2\2F\r\3\2\2\2GE\3\2\2\2HI\t\2\2\2")
        buf.write(u"IJ\5\26\f\2JK\7\3\2\2KL\5\20\t\2LM\7\4\2\2MN\5\4\3\2")
        buf.write(u"Nd\3\2\2\2Od\7$\2\2Pd\5\24\13\2QR\5\22\n\2RS\7\5\2\2")
        buf.write(u"ST\5\24\13\2Td\3\2\2\2UV\7\24\2\2VW\5\26\f\2WX\7\3\2")
        buf.write(u"\2XY\5\20\t\2YZ\7\4\2\2Z[\5\f\7\2[d\3\2\2\2\\]\5\34\17")
        buf.write(u"\2]^\5\f\7\2^d\3\2\2\2_`\7\6\2\2`a\5\4\3\2ab\7\7\2\2")
        buf.write(u"bd\3\2\2\2cH\3\2\2\2cO\3\2\2\2cP\3\2\2\2cQ\3\2\2\2cU")
        buf.write(u"\3\2\2\2c\\\3\2\2\2c_\3\2\2\2d\17\3\2\2\2ef\t\3\2\2f")
        buf.write(u"\21\3\2\2\2gn\7#\2\2hn\5\26\f\2ij\7#\2\2jk\7\b\2\2kl")
        buf.write(u"\7$\2\2ln\7\t\2\2mg\3\2\2\2mh\3\2\2\2mi\3\2\2\2n\23\3")
        buf.write(u"\2\2\2oz\7#\2\2pz\5\26\f\2qr\7#\2\2rs\7\b\2\2st\7#\2")
        buf.write(u"\2tz\7\t\2\2uv\7#\2\2vw\7\b\2\2wx\7\n\2\2xz\7\t\2\2y")
        buf.write(u"o\3\2\2\2yp\3\2\2\2yq\3\2\2\2yu\3\2\2\2z\25\3\2\2\2{")
        buf.write(u"|\7\"\2\2|\27\3\2\2\2}~\t\4\2\2~\31\3\2\2\2\177\u0080")
        buf.write(u"\t\5\2\2\u0080\33\3\2\2\2\u0081\u0082\7\37\2\2\u0082")
        buf.write(u"\35\3\2\2\2\u0083\u0084\t\6\2\2\u0084\37\3\2\2\2\u0085")
        buf.write(u"\u0086\7\r\2\2\u0086!\3\2\2\2\u0087\u0088\t\7\2\2\u0088")
        buf.write(u"#\3\2\2\2\n-\61\67=Ecmy")
        return buf.getvalue()


class DeclSpecLanguageParser ( Parser ):

    grammarFileName = "DeclSpecLanguage.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'in'", u"':'", u"'.'", u"'('", u"')'", 
                     u"'['", u"']'", u"<INVALID>", u"'and'", u"'or'", u"'not'", 
                     u"'true'", u"'false'", u"'impl'", u"'iff'", u"'exists'", 
                     u"'forall'", u"'sum'", u"'cost'", u"'<='", u"'='", 
                     u"'>='", u"'<'", u"'>'", u"'!='", u"'+'", u"'-'", u"'*'", 
                     u"'abs'", u"'obj'", u"'DC'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"RE", u"AND", u"OR", u"NOT", u"TRUE", u"FALSE", u"IMPL", 
                      u"IFF", u"EXISTS", u"FORALL", u"SUM", u"COST", u"LEQ", 
                      u"EQ", u"GEQ", u"LT", u"GT", u"NEQ", u"PLUS", u"MINUS", 
                      u"TIMES", u"ABS", u"OBJ", u"DC", u"VARIABLE", u"ID", 
                      u"INT", u"WS" ]

    RULE_statement = 0
    RULE_b_expr = 1
    RULE_b_term = 2
    RULE_b_factor = 3
    RULE_relation = 4
    RULE_expr = 5
    RULE_term = 6
    RULE_typeV = 7
    RULE_dcId = 8
    RULE_objId = 9
    RULE_variable = 10
    RULE_bool_binary_op = 11
    RULE_arith_binary_op = 12
    RULE_arith_unary_op = 13
    RULE_comparison_op = 14
    RULE_unaryOp = 15
    RULE_boolFact = 16

    ruleNames =  [ u"statement", u"b_expr", u"b_term", u"b_factor", u"relation", 
                   u"expr", u"term", u"typeV", u"dcId", u"objId", u"variable", 
                   u"bool_binary_op", u"arith_binary_op", u"arith_unary_op", 
                   u"comparison_op", u"unaryOp", u"boolFact" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    RE=8
    AND=9
    OR=10
    NOT=11
    TRUE=12
    FALSE=13
    IMPL=14
    IFF=15
    EXISTS=16
    FORALL=17
    SUM=18
    COST=19
    LEQ=20
    EQ=21
    GEQ=22
    LT=23
    GT=24
    NEQ=25
    PLUS=26
    MINUS=27
    TIMES=28
    ABS=29
    OBJ=30
    DC=31
    VARIABLE=32
    ID=33
    INT=34
    WS=35

    def __init__(self, input):
        super(DeclSpecLanguageParser, self).__init__(input)
        self.checkVersion("4.5.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def EOF(self):
            return self.getToken(DeclSpecLanguageParser.EOF, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_statement

        def accept(self, visitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = DeclSpecLanguageParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.b_expr()
            self.state = 35
            self.match(DeclSpecLanguageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_exprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_exprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_term(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.B_termContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.B_termContext,i)


        def bool_binary_op(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Bool_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Bool_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_expr

        def accept(self, visitor):
            if hasattr(visitor, "visitB_expr"):
                return visitor.visitB_expr(self)
            else:
                return visitor.visitChildren(self)




    def b_expr(self):

        localctx = DeclSpecLanguageParser.B_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_b_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self.b_term()
            self.state = 43
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 38
                    self.bool_binary_op()
                    self.state = 39
                    self.b_term() 
                self.state = 45
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_termContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_termContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_factor(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_factorContext,0)


        def unaryOp(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.UnaryOpContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_term

        def accept(self, visitor):
            if hasattr(visitor, "visitB_term"):
                return visitor.visitB_term(self)
            else:
                return visitor.visitChildren(self)




    def b_term(self):

        localctx = DeclSpecLanguageParser.B_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_b_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            _la = self._input.LA(1)
            if _la==DeclSpecLanguageParser.NOT:
                self.state = 46
                self.unaryOp()


            self.state = 49
            self.b_factor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_factorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_factorContext, self).__init__(parent, invokingState)
            self.parser = parser

        def boolFact(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.BoolFactContext,0)


        def relation(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.RelationContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_factor

        def accept(self, visitor):
            if hasattr(visitor, "visitB_factor"):
                return visitor.visitB_factor(self)
            else:
                return visitor.visitChildren(self)




    def b_factor(self):

        localctx = DeclSpecLanguageParser.B_factorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_b_factor)
        try:
            self.state = 53
            token = self._input.LA(1)
            if token in [DeclSpecLanguageParser.TRUE, DeclSpecLanguageParser.FALSE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 51
                self.boolFact()

            elif token in [DeclSpecLanguageParser.T__3, DeclSpecLanguageParser.EXISTS, DeclSpecLanguageParser.FORALL, DeclSpecLanguageParser.SUM, DeclSpecLanguageParser.ABS, DeclSpecLanguageParser.VARIABLE, DeclSpecLanguageParser.ID, DeclSpecLanguageParser.INT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 52
                self.relation()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.RelationContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.ExprContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,i)


        def comparison_op(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.Comparison_opContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_relation

        def accept(self, visitor):
            if hasattr(visitor, "visitRelation"):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = DeclSpecLanguageParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self.expr()
            self.state = 59
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 56
                self.comparison_op()
                self.state = 57
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def term(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.TermContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.TermContext,i)


        def arith_binary_op(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Arith_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Arith_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_expr

        def accept(self, visitor):
            if hasattr(visitor, "visitExpr"):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = DeclSpecLanguageParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.term()
            self.state = 67
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 62
                    self.arith_binary_op()
                    self.state = 63
                    self.term() 
                self.state = 69
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.TermContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_term

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.TermContext, self).copyFrom(ctx)



    class AtermIntContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermIntContext, self).__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtermInt"):
                return visitor.visitAtermInt(self)
            else:
                return visitor.visitChildren(self)


    class AtermIdContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermIdContext, self).__init__(parser)
            self.copyFrom(ctx)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermId"):
                return visitor.visitAtermId(self)
            else:
                return visitor.visitChildren(self)


    class AtermDCObjContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermDCObjContext, self).__init__(parser)
            self.copyFrom(ctx)

        def dcId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.DcIdContext,0)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermDCObj"):
                return visitor.visitAtermDCObj(self)
            else:
                return visitor.visitChildren(self)


    class AtermQuantifierContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermQuantifierContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)

        def EXISTS(self):
            return self.getToken(DeclSpecLanguageParser.EXISTS, 0)
        def FORALL(self):
            return self.getToken(DeclSpecLanguageParser.FORALL, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtermQuantifier"):
                return visitor.visitAtermQuantifier(self)
            else:
                return visitor.visitChildren(self)


    class AtermBracketsContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermBracketsContext, self).__init__(parser)
            self.copyFrom(ctx)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermBrackets"):
                return visitor.visitAtermBrackets(self)
            else:
                return visitor.visitChildren(self)


    class AexprUnaryArithmeticContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AexprUnaryArithmeticContext, self).__init__(parser)
            self.copyFrom(ctx)

        def arith_unary_op(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.Arith_unary_opContext,0)

        def expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAexprUnaryArithmetic"):
                return visitor.visitAexprUnaryArithmetic(self)
            else:
                return visitor.visitChildren(self)


    class AtermSumContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermSumContext, self).__init__(parser)
            self.copyFrom(ctx)

        def SUM(self):
            return self.getToken(DeclSpecLanguageParser.SUM, 0)
        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermSum"):
                return visitor.visitAtermSum(self)
            else:
                return visitor.visitChildren(self)



    def term(self):

        localctx = DeclSpecLanguageParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 97
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AtermQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                _la = self._input.LA(1)
                if not(_la==DeclSpecLanguageParser.EXISTS or _la==DeclSpecLanguageParser.FORALL):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 71
                self.variable()
                self.state = 72
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 73
                self.typeV()
                self.state = 74
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 75
                self.b_expr()
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AtermIntContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 77
                self.match(DeclSpecLanguageParser.INT)
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AtermIdContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 78
                self.objId()
                pass

            elif la_ == 4:
                localctx = DeclSpecLanguageParser.AtermDCObjContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 79
                self.dcId()
                self.state = 80
                self.match(DeclSpecLanguageParser.T__2)
                self.state = 81
                self.objId()
                pass

            elif la_ == 5:
                localctx = DeclSpecLanguageParser.AtermSumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 83
                self.match(DeclSpecLanguageParser.SUM)
                self.state = 84
                self.variable()
                self.state = 85
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 86
                self.typeV()
                self.state = 87
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 88
                self.expr()
                pass

            elif la_ == 6:
                localctx = DeclSpecLanguageParser.AexprUnaryArithmeticContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 90
                self.arith_unary_op()
                self.state = 91
                self.expr()
                pass

            elif la_ == 7:
                localctx = DeclSpecLanguageParser.AtermBracketsContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 93
                self.match(DeclSpecLanguageParser.T__3)
                self.state = 94
                self.b_expr()
                self.state = 95
                self.match(DeclSpecLanguageParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeVContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.TypeVContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OBJ(self):
            return self.getToken(DeclSpecLanguageParser.OBJ, 0)

        def DC(self):
            return self.getToken(DeclSpecLanguageParser.DC, 0)

        def RE(self):
            return self.getToken(DeclSpecLanguageParser.RE, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_typeV

        def accept(self, visitor):
            if hasattr(visitor, "visitTypeV"):
                return visitor.visitTypeV(self)
            else:
                return visitor.visitChildren(self)




    def typeV(self):

        localctx = DeclSpecLanguageParser.TypeVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_typeV)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.RE) | (1 << DeclSpecLanguageParser.OBJ) | (1 << DeclSpecLanguageParser.DC))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DcIdContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.DcIdContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_dcId

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.DcIdContext, self).copyFrom(ctx)



    class AdcIDIDContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDIDContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDID"):
                return visitor.visitAdcIDID(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDNumContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDNumContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)
        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDNum"):
                return visitor.visitAdcIDNum(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDVarContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDVarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDVar"):
                return visitor.visitAdcIDVar(self)
            else:
                return visitor.visitChildren(self)



    def dcId(self):

        localctx = DeclSpecLanguageParser.DcIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_dcId)
        try:
            self.state = 107
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AdcIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AdcIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AdcIDNumContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.match(DeclSpecLanguageParser.ID)
                self.state = 104
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 105
                self.match(DeclSpecLanguageParser.INT)
                self.state = 106
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObjIdContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.ObjIdContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_objId

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.ObjIdContext, self).copyFrom(ctx)



    class AobjIDScenarioContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDScenarioContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(DeclSpecLanguageParser.ID)
            else:
                return self.getToken(DeclSpecLanguageParser.ID, i)

        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDScenario"):
                return visitor.visitAobjIDScenario(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDREContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDREContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)
        def RE(self):
            return self.getToken(DeclSpecLanguageParser.RE, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDRE"):
                return visitor.visitAobjIDRE(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDVarContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDVarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDVar"):
                return visitor.visitAobjIDVar(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDIDContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDIDContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDID"):
                return visitor.visitAobjIDID(self)
            else:
                return visitor.visitChildren(self)



    def objId(self):

        localctx = DeclSpecLanguageParser.ObjIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objId)
        try:
            self.state = 119
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AobjIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AobjIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AobjIDScenarioContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.match(DeclSpecLanguageParser.ID)
                self.state = 112
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 113
                self.match(DeclSpecLanguageParser.ID)
                self.state = 114
                self.match(DeclSpecLanguageParser.T__6)
                pass

            elif la_ == 4:
                localctx = DeclSpecLanguageParser.AobjIDREContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 115
                self.match(DeclSpecLanguageParser.ID)
                self.state = 116
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 117
                self.match(DeclSpecLanguageParser.RE)
                self.state = 118
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.VariableContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_variable

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.VariableContext, self).copyFrom(ctx)



    class AvariableContext(VariableContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.VariableContext)
            super(DeclSpecLanguageParser.AvariableContext, self).__init__(parser)
            self.copyFrom(ctx)

        def VARIABLE(self):
            return self.getToken(DeclSpecLanguageParser.VARIABLE, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAvariable"):
                return visitor.visitAvariable(self)
            else:
                return visitor.visitChildren(self)



    def variable(self):

        localctx = DeclSpecLanguageParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        try:
            localctx = DeclSpecLanguageParser.AvariableContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(DeclSpecLanguageParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Bool_binary_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Bool_binary_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(DeclSpecLanguageParser.AND, 0)

        def OR(self):
            return self.getToken(DeclSpecLanguageParser.OR, 0)

        def IMPL(self):
            return self.getToken(DeclSpecLanguageParser.IMPL, 0)

        def IFF(self):
            return self.getToken(DeclSpecLanguageParser.IFF, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_bool_binary_op

        def accept(self, visitor):
            if hasattr(visitor, "visitBool_binary_op"):
                return visitor.visitBool_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def bool_binary_op(self):

        localctx = DeclSpecLanguageParser.Bool_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bool_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.AND) | (1 << DeclSpecLanguageParser.OR) | (1 << DeclSpecLanguageParser.IMPL) | (1 << DeclSpecLanguageParser.IFF))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_binary_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Arith_binary_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(DeclSpecLanguageParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(DeclSpecLanguageParser.MINUS, 0)

        def TIMES(self):
            return self.getToken(DeclSpecLanguageParser.TIMES, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_arith_binary_op

        def accept(self, visitor):
            if hasattr(visitor, "visitArith_binary_op"):
                return visitor.visitArith_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def arith_binary_op(self):

        localctx = DeclSpecLanguageParser.Arith_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arith_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.PLUS) | (1 << DeclSpecLanguageParser.MINUS) | (1 << DeclSpecLanguageParser.TIMES))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_unary_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Arith_unary_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(DeclSpecLanguageParser.ABS, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_arith_unary_op

        def accept(self, visitor):
            if hasattr(visitor, "visitArith_unary_op"):
                return visitor.visitArith_unary_op(self)
            else:
                return visitor.visitChildren(self)




    def arith_unary_op(self):

        localctx = DeclSpecLanguageParser.Arith_unary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arith_unary_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(DeclSpecLanguageParser.ABS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comparison_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Comparison_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEQ(self):
            return self.getToken(DeclSpecLanguageParser.LEQ, 0)

        def EQ(self):
            return self.getToken(DeclSpecLanguageParser.EQ, 0)

        def GEQ(self):
            return self.getToken(DeclSpecLanguageParser.GEQ, 0)

        def LT(self):
            return self.getToken(DeclSpecLanguageParser.LT, 0)

        def GT(self):
            return self.getToken(DeclSpecLanguageParser.GT, 0)

        def NEQ(self):
            return self.getToken(DeclSpecLanguageParser.NEQ, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_comparison_op

        def accept(self, visitor):
            if hasattr(visitor, "visitComparison_op"):
                return visitor.visitComparison_op(self)
            else:
                return visitor.visitChildren(self)




    def comparison_op(self):

        localctx = DeclSpecLanguageParser.Comparison_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_comparison_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.LEQ) | (1 << DeclSpecLanguageParser.EQ) | (1 << DeclSpecLanguageParser.GEQ) | (1 << DeclSpecLanguageParser.LT) | (1 << DeclSpecLanguageParser.GT) | (1 << DeclSpecLanguageParser.NEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryOpContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.UnaryOpContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(DeclSpecLanguageParser.NOT, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_unaryOp

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryOp"):
                return visitor.visitUnaryOp(self)
            else:
                return visitor.visitChildren(self)




    def unaryOp(self):

        localctx = DeclSpecLanguageParser.UnaryOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_unaryOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(DeclSpecLanguageParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolFactContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.BoolFactContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(DeclSpecLanguageParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(DeclSpecLanguageParser.FALSE, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_boolFact

        def accept(self, visitor):
            if hasattr(visitor, "visitBoolFact"):
                return visitor.visitBoolFact(self)
            else:
                return visitor.visitChildren(self)




    def boolFact(self):

        localctx = DeclSpecLanguageParser.BoolFactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_boolFact)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            _la = self._input.LA(1)
            if not(_la==DeclSpecLanguageParser.TRUE or _la==DeclSpecLanguageParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





