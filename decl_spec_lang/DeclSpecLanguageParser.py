# Generated from /Users/lorenzobacchiani/Desktop/abs_deployer/decl_spec_lang/DeclSpecLanguage.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,34,136,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,1,0,1,0,1,0,1,1,1,1,1,1,1,1,5,1,42,
        8,1,10,1,12,1,45,9,1,1,2,3,2,48,8,2,1,2,1,2,1,3,1,3,3,3,54,8,3,1,
        4,1,4,1,4,1,4,3,4,60,8,4,1,5,1,5,1,5,1,5,5,5,66,8,5,10,5,12,5,69,
        9,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,
        1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,98,8,6,1,7,1,
        7,1,8,1,8,1,8,1,8,1,8,1,8,3,8,108,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,
        9,1,9,1,9,1,9,3,9,120,8,9,1,10,1,10,1,11,1,11,1,12,1,12,1,13,1,13,
        1,14,1,14,1,15,1,15,1,16,1,16,1,16,0,0,17,0,2,4,6,8,10,12,14,16,
        18,20,22,24,26,28,30,32,0,6,1,0,16,17,2,0,8,8,29,30,2,0,9,10,14,
        15,1,0,25,27,1,0,19,24,1,0,12,13,134,0,34,1,0,0,0,2,37,1,0,0,0,4,
        47,1,0,0,0,6,53,1,0,0,0,8,55,1,0,0,0,10,61,1,0,0,0,12,97,1,0,0,0,
        14,99,1,0,0,0,16,107,1,0,0,0,18,119,1,0,0,0,20,121,1,0,0,0,22,123,
        1,0,0,0,24,125,1,0,0,0,26,127,1,0,0,0,28,129,1,0,0,0,30,131,1,0,
        0,0,32,133,1,0,0,0,34,35,3,2,1,0,35,36,5,0,0,1,36,1,1,0,0,0,37,43,
        3,4,2,0,38,39,3,22,11,0,39,40,3,4,2,0,40,42,1,0,0,0,41,38,1,0,0,
        0,42,45,1,0,0,0,43,41,1,0,0,0,43,44,1,0,0,0,44,3,1,0,0,0,45,43,1,
        0,0,0,46,48,3,30,15,0,47,46,1,0,0,0,47,48,1,0,0,0,48,49,1,0,0,0,
        49,50,3,6,3,0,50,5,1,0,0,0,51,54,3,32,16,0,52,54,3,8,4,0,53,51,1,
        0,0,0,53,52,1,0,0,0,54,7,1,0,0,0,55,59,3,10,5,0,56,57,3,28,14,0,
        57,58,3,10,5,0,58,60,1,0,0,0,59,56,1,0,0,0,59,60,1,0,0,0,60,9,1,
        0,0,0,61,67,3,12,6,0,62,63,3,24,12,0,63,64,3,12,6,0,64,66,1,0,0,
        0,65,62,1,0,0,0,66,69,1,0,0,0,67,65,1,0,0,0,67,68,1,0,0,0,68,11,
        1,0,0,0,69,67,1,0,0,0,70,71,7,0,0,0,71,72,3,20,10,0,72,73,5,1,0,
        0,73,74,3,14,7,0,74,75,5,2,0,0,75,76,3,2,1,0,76,98,1,0,0,0,77,98,
        5,33,0,0,78,98,3,18,9,0,79,80,3,16,8,0,80,81,5,3,0,0,81,82,3,18,
        9,0,82,98,1,0,0,0,83,84,5,18,0,0,84,85,3,20,10,0,85,86,5,1,0,0,86,
        87,3,14,7,0,87,88,5,2,0,0,88,89,3,10,5,0,89,98,1,0,0,0,90,91,3,26,
        13,0,91,92,3,10,5,0,92,98,1,0,0,0,93,94,5,4,0,0,94,95,3,2,1,0,95,
        96,5,5,0,0,96,98,1,0,0,0,97,70,1,0,0,0,97,77,1,0,0,0,97,78,1,0,0,
        0,97,79,1,0,0,0,97,83,1,0,0,0,97,90,1,0,0,0,97,93,1,0,0,0,98,13,
        1,0,0,0,99,100,7,1,0,0,100,15,1,0,0,0,101,108,5,32,0,0,102,108,3,
        20,10,0,103,104,5,32,0,0,104,105,5,6,0,0,105,106,5,33,0,0,106,108,
        5,7,0,0,107,101,1,0,0,0,107,102,1,0,0,0,107,103,1,0,0,0,108,17,1,
        0,0,0,109,120,5,32,0,0,110,120,3,20,10,0,111,112,5,32,0,0,112,113,
        5,6,0,0,113,114,5,32,0,0,114,120,5,7,0,0,115,116,5,32,0,0,116,117,
        5,6,0,0,117,118,5,8,0,0,118,120,5,7,0,0,119,109,1,0,0,0,119,110,
        1,0,0,0,119,111,1,0,0,0,119,115,1,0,0,0,120,19,1,0,0,0,121,122,5,
        31,0,0,122,21,1,0,0,0,123,124,7,2,0,0,124,23,1,0,0,0,125,126,7,3,
        0,0,126,25,1,0,0,0,127,128,5,28,0,0,128,27,1,0,0,0,129,130,7,4,0,
        0,130,29,1,0,0,0,131,132,5,11,0,0,132,31,1,0,0,0,133,134,7,5,0,0,
        134,33,1,0,0,0,8,43,47,53,59,67,97,107,119
    ]

class DeclSpecLanguageParser ( Parser ):

    grammarFileName = "DeclSpecLanguage.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'in'", "':'", "'.'", "'('", "')'", "'['", 
                     "']'", "<INVALID>", "'and'", "'or'", "'not'", "'true'", 
                     "'false'", "'impl'", "'iff'", "'exists'", "'forall'", 
                     "'sum'", "'<='", "'='", "'>='", "'<'", "'>'", "'!='", 
                     "'+'", "'-'", "'*'", "'abs'", "'obj'", "'DC'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "RE", "AND", "OR", "NOT", "TRUE", "FALSE", "IMPL", 
                      "IFF", "EXISTS", "FORALL", "SUM", "LEQ", "EQ", "GEQ", 
                      "LT", "GT", "NEQ", "PLUS", "MINUS", "TIMES", "ABS", 
                      "OBJ", "DC", "VARIABLE", "ID", "INT", "WS" ]

    RULE_statement = 0
    RULE_b_expr = 1
    RULE_b_term = 2
    RULE_b_factor = 3
    RULE_relation = 4
    RULE_expr = 5
    RULE_term = 6
    RULE_typeV = 7
    RULE_dcId = 8
    RULE_objId = 9
    RULE_variable = 10
    RULE_bool_binary_op = 11
    RULE_arith_binary_op = 12
    RULE_arith_unary_op = 13
    RULE_comparison_op = 14
    RULE_unaryOp = 15
    RULE_boolFact = 16

    ruleNames =  [ "statement", "b_expr", "b_term", "b_factor", "relation", 
                   "expr", "term", "typeV", "dcId", "objId", "variable", 
                   "bool_binary_op", "arith_binary_op", "arith_unary_op", 
                   "comparison_op", "unaryOp", "boolFact" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    RE=8
    AND=9
    OR=10
    NOT=11
    TRUE=12
    FALSE=13
    IMPL=14
    IFF=15
    EXISTS=16
    FORALL=17
    SUM=18
    LEQ=19
    EQ=20
    GEQ=21
    LT=22
    GT=23
    NEQ=24
    PLUS=25
    MINUS=26
    TIMES=27
    ABS=28
    OBJ=29
    DC=30
    VARIABLE=31
    ID=32
    INT=33
    WS=34

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def EOF(self):
            return self.getToken(DeclSpecLanguageParser.EOF, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = DeclSpecLanguageParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.b_expr()
            self.state = 35
            self.match(DeclSpecLanguageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class B_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def b_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.B_termContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.B_termContext,i)


        def bool_binary_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Bool_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Bool_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterB_expr" ):
                listener.enterB_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitB_expr" ):
                listener.exitB_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitB_expr" ):
                return visitor.visitB_expr(self)
            else:
                return visitor.visitChildren(self)




    def b_expr(self):

        localctx = DeclSpecLanguageParser.B_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_b_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self.b_term()
            self.state = 43
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 38
                    self.bool_binary_op()
                    self.state = 39
                    self.b_term() 
                self.state = 45
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class B_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def b_factor(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_factorContext,0)


        def unaryOp(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.UnaryOpContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterB_term" ):
                listener.enterB_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitB_term" ):
                listener.exitB_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitB_term" ):
                return visitor.visitB_term(self)
            else:
                return visitor.visitChildren(self)




    def b_term(self):

        localctx = DeclSpecLanguageParser.B_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_b_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 46
                self.unaryOp()


            self.state = 49
            self.b_factor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class B_factorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolFact(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.BoolFactContext,0)


        def relation(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.RelationContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterB_factor" ):
                listener.enterB_factor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitB_factor" ):
                listener.exitB_factor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitB_factor" ):
                return visitor.visitB_factor(self)
            else:
                return visitor.visitChildren(self)




    def b_factor(self):

        localctx = DeclSpecLanguageParser.B_factorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_b_factor)
        try:
            self.state = 53
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12, 13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 51
                self.boolFact()
                pass
            elif token in [4, 16, 17, 18, 28, 31, 32, 33]:
                self.enterOuterAlt(localctx, 2)
                self.state = 52
                self.relation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.ExprContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,i)


        def comparison_op(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.Comparison_opContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelation" ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = DeclSpecLanguageParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self.expr()
            self.state = 59
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 56
                self.comparison_op()
                self.state = 57
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.TermContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.TermContext,i)


        def arith_binary_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Arith_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Arith_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = DeclSpecLanguageParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.term()
            self.state = 67
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 62
                    self.arith_binary_op()
                    self.state = 63
                    self.term() 
                self.state = 69
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_term

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AtermIntContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermInt" ):
                listener.enterAtermInt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermInt" ):
                listener.exitAtermInt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermInt" ):
                return visitor.visitAtermInt(self)
            else:
                return visitor.visitChildren(self)


    class AtermIdContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermId" ):
                listener.enterAtermId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermId" ):
                listener.exitAtermId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermId" ):
                return visitor.visitAtermId(self)
            else:
                return visitor.visitChildren(self)


    class AtermDCObjContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def dcId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.DcIdContext,0)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermDCObj" ):
                listener.enterAtermDCObj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermDCObj" ):
                listener.exitAtermDCObj(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermDCObj" ):
                return visitor.visitAtermDCObj(self)
            else:
                return visitor.visitChildren(self)


    class AtermQuantifierContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)

        def EXISTS(self):
            return self.getToken(DeclSpecLanguageParser.EXISTS, 0)
        def FORALL(self):
            return self.getToken(DeclSpecLanguageParser.FORALL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermQuantifier" ):
                listener.enterAtermQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermQuantifier" ):
                listener.exitAtermQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermQuantifier" ):
                return visitor.visitAtermQuantifier(self)
            else:
                return visitor.visitChildren(self)


    class AtermBracketsContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermBrackets" ):
                listener.enterAtermBrackets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermBrackets" ):
                listener.exitAtermBrackets(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermBrackets" ):
                return visitor.visitAtermBrackets(self)
            else:
                return visitor.visitChildren(self)


    class AexprUnaryArithmeticContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arith_unary_op(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.Arith_unary_opContext,0)

        def expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAexprUnaryArithmetic" ):
                listener.enterAexprUnaryArithmetic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAexprUnaryArithmetic" ):
                listener.exitAexprUnaryArithmetic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAexprUnaryArithmetic" ):
                return visitor.visitAexprUnaryArithmetic(self)
            else:
                return visitor.visitChildren(self)


    class AtermSumContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUM(self):
            return self.getToken(DeclSpecLanguageParser.SUM, 0)
        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtermSum" ):
                listener.enterAtermSum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtermSum" ):
                listener.exitAtermSum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtermSum" ):
                return visitor.visitAtermSum(self)
            else:
                return visitor.visitChildren(self)



    def term(self):

        localctx = DeclSpecLanguageParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 97
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AtermQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                _la = self._input.LA(1)
                if not(_la==16 or _la==17):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 71
                self.variable()
                self.state = 72
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 73
                self.typeV()
                self.state = 74
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 75
                self.b_expr()
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AtermIntContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 77
                self.match(DeclSpecLanguageParser.INT)
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AtermIdContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 78
                self.objId()
                pass

            elif la_ == 4:
                localctx = DeclSpecLanguageParser.AtermDCObjContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 79
                self.dcId()
                self.state = 80
                self.match(DeclSpecLanguageParser.T__2)
                self.state = 81
                self.objId()
                pass

            elif la_ == 5:
                localctx = DeclSpecLanguageParser.AtermSumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 83
                self.match(DeclSpecLanguageParser.SUM)
                self.state = 84
                self.variable()
                self.state = 85
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 86
                self.typeV()
                self.state = 87
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 88
                self.expr()
                pass

            elif la_ == 6:
                localctx = DeclSpecLanguageParser.AexprUnaryArithmeticContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 90
                self.arith_unary_op()
                self.state = 91
                self.expr()
                pass

            elif la_ == 7:
                localctx = DeclSpecLanguageParser.AtermBracketsContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 93
                self.match(DeclSpecLanguageParser.T__3)
                self.state = 94
                self.b_expr()
                self.state = 95
                self.match(DeclSpecLanguageParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeVContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJ(self):
            return self.getToken(DeclSpecLanguageParser.OBJ, 0)

        def DC(self):
            return self.getToken(DeclSpecLanguageParser.DC, 0)

        def RE(self):
            return self.getToken(DeclSpecLanguageParser.RE, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_typeV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeV" ):
                listener.enterTypeV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeV" ):
                listener.exitTypeV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeV" ):
                return visitor.visitTypeV(self)
            else:
                return visitor.visitChildren(self)




    def typeV(self):

        localctx = DeclSpecLanguageParser.TypeVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_typeV)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1610612992) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DcIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_dcId

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AdcIDIDContext(DcIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.DcIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdcIDID" ):
                listener.enterAdcIDID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdcIDID" ):
                listener.exitAdcIDID(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdcIDID" ):
                return visitor.visitAdcIDID(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDNumContext(DcIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.DcIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)
        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdcIDNum" ):
                listener.enterAdcIDNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdcIDNum" ):
                listener.exitAdcIDNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdcIDNum" ):
                return visitor.visitAdcIDNum(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDVarContext(DcIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.DcIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdcIDVar" ):
                listener.enterAdcIDVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdcIDVar" ):
                listener.exitAdcIDVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdcIDVar" ):
                return visitor.visitAdcIDVar(self)
            else:
                return visitor.visitChildren(self)



    def dcId(self):

        localctx = DeclSpecLanguageParser.DcIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_dcId)
        try:
            self.state = 107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AdcIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AdcIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AdcIDNumContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.match(DeclSpecLanguageParser.ID)
                self.state = 104
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 105
                self.match(DeclSpecLanguageParser.INT)
                self.state = 106
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_objId

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AobjIDScenarioContext(ObjIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.ObjIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(DeclSpecLanguageParser.ID)
            else:
                return self.getToken(DeclSpecLanguageParser.ID, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAobjIDScenario" ):
                listener.enterAobjIDScenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAobjIDScenario" ):
                listener.exitAobjIDScenario(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAobjIDScenario" ):
                return visitor.visitAobjIDScenario(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDREContext(ObjIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.ObjIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)
        def RE(self):
            return self.getToken(DeclSpecLanguageParser.RE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAobjIDRE" ):
                listener.enterAobjIDRE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAobjIDRE" ):
                listener.exitAobjIDRE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAobjIDRE" ):
                return visitor.visitAobjIDRE(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDVarContext(ObjIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.ObjIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAobjIDVar" ):
                listener.enterAobjIDVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAobjIDVar" ):
                listener.exitAobjIDVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAobjIDVar" ):
                return visitor.visitAobjIDVar(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDIDContext(ObjIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.ObjIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAobjIDID" ):
                listener.enterAobjIDID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAobjIDID" ):
                listener.exitAobjIDID(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAobjIDID" ):
                return visitor.visitAobjIDID(self)
            else:
                return visitor.visitChildren(self)



    def objId(self):

        localctx = DeclSpecLanguageParser.ObjIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objId)
        try:
            self.state = 119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AobjIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AobjIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AobjIDScenarioContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.match(DeclSpecLanguageParser.ID)
                self.state = 112
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 113
                self.match(DeclSpecLanguageParser.ID)
                self.state = 114
                self.match(DeclSpecLanguageParser.T__6)
                pass

            elif la_ == 4:
                localctx = DeclSpecLanguageParser.AobjIDREContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 115
                self.match(DeclSpecLanguageParser.ID)
                self.state = 116
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 117
                self.match(DeclSpecLanguageParser.RE)
                self.state = 118
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_variable

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AvariableContext(VariableContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DeclSpecLanguageParser.VariableContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VARIABLE(self):
            return self.getToken(DeclSpecLanguageParser.VARIABLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAvariable" ):
                listener.enterAvariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAvariable" ):
                listener.exitAvariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAvariable" ):
                return visitor.visitAvariable(self)
            else:
                return visitor.visitChildren(self)



    def variable(self):

        localctx = DeclSpecLanguageParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        try:
            localctx = DeclSpecLanguageParser.AvariableContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(DeclSpecLanguageParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_binary_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(DeclSpecLanguageParser.AND, 0)

        def OR(self):
            return self.getToken(DeclSpecLanguageParser.OR, 0)

        def IMPL(self):
            return self.getToken(DeclSpecLanguageParser.IMPL, 0)

        def IFF(self):
            return self.getToken(DeclSpecLanguageParser.IFF, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_bool_binary_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBool_binary_op" ):
                listener.enterBool_binary_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBool_binary_op" ):
                listener.exitBool_binary_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBool_binary_op" ):
                return visitor.visitBool_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def bool_binary_op(self):

        localctx = DeclSpecLanguageParser.Bool_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bool_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 50688) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arith_binary_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(DeclSpecLanguageParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(DeclSpecLanguageParser.MINUS, 0)

        def TIMES(self):
            return self.getToken(DeclSpecLanguageParser.TIMES, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_arith_binary_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArith_binary_op" ):
                listener.enterArith_binary_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArith_binary_op" ):
                listener.exitArith_binary_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArith_binary_op" ):
                return visitor.visitArith_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def arith_binary_op(self):

        localctx = DeclSpecLanguageParser.Arith_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arith_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 234881024) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arith_unary_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(DeclSpecLanguageParser.ABS, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_arith_unary_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArith_unary_op" ):
                listener.enterArith_unary_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArith_unary_op" ):
                listener.exitArith_unary_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArith_unary_op" ):
                return visitor.visitArith_unary_op(self)
            else:
                return visitor.visitChildren(self)




    def arith_unary_op(self):

        localctx = DeclSpecLanguageParser.Arith_unary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arith_unary_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(DeclSpecLanguageParser.ABS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comparison_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEQ(self):
            return self.getToken(DeclSpecLanguageParser.LEQ, 0)

        def EQ(self):
            return self.getToken(DeclSpecLanguageParser.EQ, 0)

        def GEQ(self):
            return self.getToken(DeclSpecLanguageParser.GEQ, 0)

        def LT(self):
            return self.getToken(DeclSpecLanguageParser.LT, 0)

        def GT(self):
            return self.getToken(DeclSpecLanguageParser.GT, 0)

        def NEQ(self):
            return self.getToken(DeclSpecLanguageParser.NEQ, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_comparison_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison_op" ):
                listener.enterComparison_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison_op" ):
                listener.exitComparison_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison_op" ):
                return visitor.visitComparison_op(self)
            else:
                return visitor.visitChildren(self)




    def comparison_op(self):

        localctx = DeclSpecLanguageParser.Comparison_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_comparison_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 33030144) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(DeclSpecLanguageParser.NOT, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_unaryOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryOp" ):
                listener.enterUnaryOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryOp" ):
                listener.exitUnaryOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryOp" ):
                return visitor.visitUnaryOp(self)
            else:
                return visitor.visitChildren(self)




    def unaryOp(self):

        localctx = DeclSpecLanguageParser.UnaryOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_unaryOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(DeclSpecLanguageParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolFactContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(DeclSpecLanguageParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(DeclSpecLanguageParser.FALSE, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_boolFact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolFact" ):
                listener.enterBoolFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolFact" ):
                listener.exitBoolFact(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolFact" ):
                return visitor.visitBoolFact(self)
            else:
                return visitor.visitChildren(self)




    def boolFact(self):

        localctx = DeclSpecLanguageParser.BoolFactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_boolFact)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            _la = self._input.LA(1)
            if not(_la==12 or _la==13):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





