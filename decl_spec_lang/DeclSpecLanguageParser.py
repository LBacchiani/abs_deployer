# Generated from DeclSpecLanguage.g4 by ANTLR 4.5.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"#~\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4")
        buf.write(u"\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write(u"\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\3\3\3\3\3")
        buf.write(u"\3\3\3\7\3)\n\3\f\3\16\3,\13\3\3\4\5\4/\n\4\3\4\3\4\3")
        buf.write(u"\5\3\5\5\5\65\n\5\3\6\3\6\3\6\3\6\5\6;\n\6\3\7\3\7\3")
        buf.write(u"\7\3\7\7\7A\n\7\f\7\16\7D\13\7\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\5\b^\n\b\3\t\3\t\3\n\3\n\3\n\3")
        buf.write(u"\n\3\n\3\n\5\nh\n\n\3\13\3\13\3\13\3\13\3\13\3\13\5\13")
        buf.write(u"p\n\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3\20")
        buf.write(u"\3\21\3\21\3\21\2\2\22\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write(u"\32\34\36 \2\7\3\2\21\22\4\2\36\37!!\4\2\n\13\17\20\3")
        buf.write(u"\2\33\35\3\2\25\32{\2\"\3\2\2\2\4$\3\2\2\2\6.\3\2\2\2")
        buf.write(u"\b\64\3\2\2\2\n\66\3\2\2\2\f<\3\2\2\2\16]\3\2\2\2\20")
        buf.write(u"_\3\2\2\2\22g\3\2\2\2\24o\3\2\2\2\26q\3\2\2\2\30s\3\2")
        buf.write(u"\2\2\32u\3\2\2\2\34w\3\2\2\2\36y\3\2\2\2 {\3\2\2\2\"")
        buf.write(u"#\5\4\3\2#\3\3\2\2\2$*\5\6\4\2%&\5\30\r\2&\'\5\6\4\2")
        buf.write(u"\')\3\2\2\2(%\3\2\2\2),\3\2\2\2*(\3\2\2\2*+\3\2\2\2+")
        buf.write(u"\5\3\2\2\2,*\3\2\2\2-/\5\36\20\2.-\3\2\2\2./\3\2\2\2")
        buf.write(u"/\60\3\2\2\2\60\61\5\b\5\2\61\7\3\2\2\2\62\65\5 \21\2")
        buf.write(u"\63\65\5\n\6\2\64\62\3\2\2\2\64\63\3\2\2\2\65\t\3\2\2")
        buf.write(u"\2\66:\5\f\7\2\678\5\34\17\289\5\f\7\29;\3\2\2\2:\67")
        buf.write(u"\3\2\2\2:;\3\2\2\2;\13\3\2\2\2<B\5\16\b\2=>\5\32\16\2")
        buf.write(u">?\5\16\b\2?A\3\2\2\2@=\3\2\2\2AD\3\2\2\2B@\3\2\2\2B")
        buf.write(u"C\3\2\2\2C\r\3\2\2\2DB\3\2\2\2EF\t\2\2\2FG\5\26\f\2G")
        buf.write(u"H\7\3\2\2HI\5\20\t\2IJ\7\4\2\2JK\5\4\3\2K^\3\2\2\2L^")
        buf.write(u"\7\"\2\2M^\5\24\13\2NO\5\22\n\2OP\7\5\2\2PQ\5\24\13\2")
        buf.write(u"Q^\3\2\2\2RS\7\23\2\2ST\5\26\f\2TU\7\3\2\2UV\5\20\t\2")
        buf.write(u"VW\7\4\2\2WX\5\f\7\2X^\3\2\2\2YZ\7\6\2\2Z[\5\4\3\2[\\")
        buf.write(u"\7\7\2\2\\^\3\2\2\2]E\3\2\2\2]L\3\2\2\2]M\3\2\2\2]N\3")
        buf.write(u"\2\2\2]R\3\2\2\2]Y\3\2\2\2^\17\3\2\2\2_`\t\3\2\2`\21")
        buf.write(u"\3\2\2\2ah\7!\2\2bh\5\26\f\2cd\7!\2\2de\7\b\2\2ef\7\"")
        buf.write(u"\2\2fh\7\t\2\2ga\3\2\2\2gb\3\2\2\2gc\3\2\2\2h\23\3\2")
        buf.write(u"\2\2ip\7!\2\2jp\5\26\f\2kl\7!\2\2lm\7\b\2\2mn\7!\2\2")
        buf.write(u"np\7\t\2\2oi\3\2\2\2oj\3\2\2\2ok\3\2\2\2p\25\3\2\2\2")
        buf.write(u"qr\7 \2\2r\27\3\2\2\2st\t\4\2\2t\31\3\2\2\2uv\t\5\2\2")
        buf.write(u"v\33\3\2\2\2wx\t\6\2\2x\35\3\2\2\2yz\7\f\2\2z\37\3\2")
        buf.write(u"\2\2{|\7\r\2\2|!\3\2\2\2\n*.\64:B]go")
        return buf.getvalue()


class DeclSpecLanguageParser ( Parser ):

    grammarFileName = "DeclSpecLanguage.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'in'", u"':'", u"'.'", u"'('", u"')'", 
                     u"'['", u"']'", u"'and'", u"'or'", u"'not'", u"'true'", 
                     u"'false'", u"'impl'", u"'iff'", u"'exists'", u"'forall'", 
                     u"'sum'", u"'cost'", u"'<='", u"'='", u"'>='", u"'<'", 
                     u"'>'", u"'!='", u"'+'", u"'-'", u"'*'", u"'obj'", 
                     u"'DC'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"AND", u"OR", u"NOT", u"TRUE", u"FALSE", u"IMPL", 
                      u"IFF", u"EXISTS", u"FORALL", u"SUM", u"COST", u"LEQ", 
                      u"EQ", u"GEQ", u"LT", u"GT", u"NEQ", u"PLUS", u"MINUS", 
                      u"TIMES", u"OBJ", u"DC", u"VARIABLE", u"ID", u"INT", 
                      u"WS" ]

    RULE_statement = 0
    RULE_b_expr = 1
    RULE_b_term = 2
    RULE_b_factor = 3
    RULE_relation = 4
    RULE_expr = 5
    RULE_term = 6
    RULE_typeV = 7
    RULE_dcId = 8
    RULE_objId = 9
    RULE_variable = 10
    RULE_bool_binary_op = 11
    RULE_arith_binary_op = 12
    RULE_comparison_op = 13
    RULE_unaryOp = 14
    RULE_boolFact = 15

    ruleNames =  [ u"statement", u"b_expr", u"b_term", u"b_factor", u"relation", 
                   u"expr", u"term", u"typeV", u"dcId", u"objId", u"variable", 
                   u"bool_binary_op", u"arith_binary_op", u"comparison_op", 
                   u"unaryOp", u"boolFact" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    AND=8
    OR=9
    NOT=10
    TRUE=11
    FALSE=12
    IMPL=13
    IFF=14
    EXISTS=15
    FORALL=16
    SUM=17
    COST=18
    LEQ=19
    EQ=20
    GEQ=21
    LT=22
    GT=23
    NEQ=24
    PLUS=25
    MINUS=26
    TIMES=27
    OBJ=28
    DC=29
    VARIABLE=30
    ID=31
    INT=32
    WS=33

    def __init__(self, input):
        super(DeclSpecLanguageParser, self).__init__(input)
        self.checkVersion("4.5.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_statement

        def accept(self, visitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = DeclSpecLanguageParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.b_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_exprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_exprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_term(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.B_termContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.B_termContext,i)


        def bool_binary_op(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Bool_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Bool_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_expr

        def accept(self, visitor):
            if hasattr(visitor, "visitB_expr"):
                return visitor.visitB_expr(self)
            else:
                return visitor.visitChildren(self)




    def b_expr(self):

        localctx = DeclSpecLanguageParser.B_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_b_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self.b_term()
            self.state = 40
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 35
                    self.bool_binary_op()
                    self.state = 36
                    self.b_term() 
                self.state = 42
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_termContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_termContext, self).__init__(parent, invokingState)
            self.parser = parser

        def b_factor(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_factorContext,0)


        def unaryOp(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.UnaryOpContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_term

        def accept(self, visitor):
            if hasattr(visitor, "visitB_term"):
                return visitor.visitB_term(self)
            else:
                return visitor.visitChildren(self)




    def b_term(self):

        localctx = DeclSpecLanguageParser.B_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_b_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            _la = self._input.LA(1)
            if _la==DeclSpecLanguageParser.NOT:
                self.state = 43
                self.unaryOp()


            self.state = 46
            self.b_factor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class B_factorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.B_factorContext, self).__init__(parent, invokingState)
            self.parser = parser

        def boolFact(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.BoolFactContext,0)


        def relation(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.RelationContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_b_factor

        def accept(self, visitor):
            if hasattr(visitor, "visitB_factor"):
                return visitor.visitB_factor(self)
            else:
                return visitor.visitChildren(self)




    def b_factor(self):

        localctx = DeclSpecLanguageParser.B_factorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_b_factor)
        try:
            self.state = 50
            token = self._input.LA(1)
            if token in [DeclSpecLanguageParser.TRUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.boolFact()

            elif token in [DeclSpecLanguageParser.T__3, DeclSpecLanguageParser.EXISTS, DeclSpecLanguageParser.FORALL, DeclSpecLanguageParser.SUM, DeclSpecLanguageParser.VARIABLE, DeclSpecLanguageParser.ID, DeclSpecLanguageParser.INT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 49
                self.relation()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.RelationContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.ExprContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,i)


        def comparison_op(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.Comparison_opContext,0)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_relation

        def accept(self, visitor):
            if hasattr(visitor, "visitRelation"):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = DeclSpecLanguageParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.expr()
            self.state = 56
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 53
                self.comparison_op()
                self.state = 54
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def term(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.TermContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.TermContext,i)


        def arith_binary_op(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(DeclSpecLanguageParser.Arith_binary_opContext)
            else:
                return self.getTypedRuleContext(DeclSpecLanguageParser.Arith_binary_opContext,i)


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_expr

        def accept(self, visitor):
            if hasattr(visitor, "visitExpr"):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = DeclSpecLanguageParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.term()
            self.state = 64
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 59
                    self.arith_binary_op()
                    self.state = 60
                    self.term() 
                self.state = 66
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.TermContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_term

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.TermContext, self).copyFrom(ctx)



    class AtermIntContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermIntContext, self).__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtermInt"):
                return visitor.visitAtermInt(self)
            else:
                return visitor.visitChildren(self)


    class AtermIdContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermIdContext, self).__init__(parser)
            self.copyFrom(ctx)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermId"):
                return visitor.visitAtermId(self)
            else:
                return visitor.visitChildren(self)


    class AtermDCObjContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermDCObjContext, self).__init__(parser)
            self.copyFrom(ctx)

        def dcId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.DcIdContext,0)

        def objId(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ObjIdContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermDCObj"):
                return visitor.visitAtermDCObj(self)
            else:
                return visitor.visitChildren(self)


    class AtermQuantifierContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermQuantifierContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)

        def EXISTS(self):
            return self.getToken(DeclSpecLanguageParser.EXISTS, 0)
        def FORALL(self):
            return self.getToken(DeclSpecLanguageParser.FORALL, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtermQuantifier"):
                return visitor.visitAtermQuantifier(self)
            else:
                return visitor.visitChildren(self)


    class AtermBracketsContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermBracketsContext, self).__init__(parser)
            self.copyFrom(ctx)

        def b_expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.B_exprContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermBrackets"):
                return visitor.visitAtermBrackets(self)
            else:
                return visitor.visitChildren(self)


    class AtermSumContext(TermContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.TermContext)
            super(DeclSpecLanguageParser.AtermSumContext, self).__init__(parser)
            self.copyFrom(ctx)

        def SUM(self):
            return self.getToken(DeclSpecLanguageParser.SUM, 0)
        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)

        def typeV(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.TypeVContext,0)

        def expr(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.ExprContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAtermSum"):
                return visitor.visitAtermSum(self)
            else:
                return visitor.visitChildren(self)



    def term(self):

        localctx = DeclSpecLanguageParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 91
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AtermQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 67
                _la = self._input.LA(1)
                if not(_la==DeclSpecLanguageParser.EXISTS or _la==DeclSpecLanguageParser.FORALL):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 68
                self.variable()
                self.state = 69
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 70
                self.typeV()
                self.state = 71
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 72
                self.b_expr()
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AtermIntContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.match(DeclSpecLanguageParser.INT)
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AtermIdContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 75
                self.objId()
                pass

            elif la_ == 4:
                localctx = DeclSpecLanguageParser.AtermDCObjContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 76
                self.dcId()
                self.state = 77
                self.match(DeclSpecLanguageParser.T__2)
                self.state = 78
                self.objId()
                pass

            elif la_ == 5:
                localctx = DeclSpecLanguageParser.AtermSumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 80
                self.match(DeclSpecLanguageParser.SUM)
                self.state = 81
                self.variable()
                self.state = 82
                self.match(DeclSpecLanguageParser.T__0)
                self.state = 83
                self.typeV()
                self.state = 84
                self.match(DeclSpecLanguageParser.T__1)
                self.state = 85
                self.expr()
                pass

            elif la_ == 6:
                localctx = DeclSpecLanguageParser.AtermBracketsContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 87
                self.match(DeclSpecLanguageParser.T__3)
                self.state = 88
                self.b_expr()
                self.state = 89
                self.match(DeclSpecLanguageParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeVContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.TypeVContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OBJ(self):
            return self.getToken(DeclSpecLanguageParser.OBJ, 0)

        def DC(self):
            return self.getToken(DeclSpecLanguageParser.DC, 0)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_typeV

        def accept(self, visitor):
            if hasattr(visitor, "visitTypeV"):
                return visitor.visitTypeV(self)
            else:
                return visitor.visitChildren(self)




    def typeV(self):

        localctx = DeclSpecLanguageParser.TypeVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_typeV)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.OBJ) | (1 << DeclSpecLanguageParser.DC) | (1 << DeclSpecLanguageParser.ID))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DcIdContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.DcIdContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_dcId

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.DcIdContext, self).copyFrom(ctx)



    class AdcIDIDContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDIDContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDID"):
                return visitor.visitAdcIDID(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDNumContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDNumContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)
        def INT(self):
            return self.getToken(DeclSpecLanguageParser.INT, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDNum"):
                return visitor.visitAdcIDNum(self)
            else:
                return visitor.visitChildren(self)


    class AdcIDVarContext(DcIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.DcIdContext)
            super(DeclSpecLanguageParser.AdcIDVarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAdcIDVar"):
                return visitor.visitAdcIDVar(self)
            else:
                return visitor.visitChildren(self)



    def dcId(self):

        localctx = DeclSpecLanguageParser.DcIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_dcId)
        try:
            self.state = 101
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AdcIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AdcIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AdcIDNumContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 97
                self.match(DeclSpecLanguageParser.ID)
                self.state = 98
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 99
                self.match(DeclSpecLanguageParser.INT)
                self.state = 100
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObjIdContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.ObjIdContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_objId

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.ObjIdContext, self).copyFrom(ctx)



    class AobjIDScenarioContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDScenarioContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(DeclSpecLanguageParser.ID)
            else:
                return self.getToken(DeclSpecLanguageParser.ID, i)

        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDScenario"):
                return visitor.visitAobjIDScenario(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDVarContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDVarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(DeclSpecLanguageParser.VariableContext,0)


        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDVar"):
                return visitor.visitAobjIDVar(self)
            else:
                return visitor.visitChildren(self)


    class AobjIDIDContext(ObjIdContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.ObjIdContext)
            super(DeclSpecLanguageParser.AobjIDIDContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(DeclSpecLanguageParser.ID, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAobjIDID"):
                return visitor.visitAobjIDID(self)
            else:
                return visitor.visitChildren(self)



    def objId(self):

        localctx = DeclSpecLanguageParser.ObjIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objId)
        try:
            self.state = 109
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = DeclSpecLanguageParser.AobjIDIDContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 103
                self.match(DeclSpecLanguageParser.ID)
                pass

            elif la_ == 2:
                localctx = DeclSpecLanguageParser.AobjIDVarContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.variable()
                pass

            elif la_ == 3:
                localctx = DeclSpecLanguageParser.AobjIDScenarioContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 105
                self.match(DeclSpecLanguageParser.ID)
                self.state = 106
                self.match(DeclSpecLanguageParser.T__5)
                self.state = 107
                self.match(DeclSpecLanguageParser.ID)
                self.state = 108
                self.match(DeclSpecLanguageParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.VariableContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_variable

     
        def copyFrom(self, ctx):
            super(DeclSpecLanguageParser.VariableContext, self).copyFrom(ctx)



    class AvariableContext(VariableContext):

        def __init__(self, parser, ctx): # actually a DeclSpecLanguageParser.VariableContext)
            super(DeclSpecLanguageParser.AvariableContext, self).__init__(parser)
            self.copyFrom(ctx)

        def VARIABLE(self):
            return self.getToken(DeclSpecLanguageParser.VARIABLE, 0)

        def accept(self, visitor):
            if hasattr(visitor, "visitAvariable"):
                return visitor.visitAvariable(self)
            else:
                return visitor.visitChildren(self)



    def variable(self):

        localctx = DeclSpecLanguageParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        try:
            localctx = DeclSpecLanguageParser.AvariableContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(DeclSpecLanguageParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Bool_binary_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Bool_binary_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(DeclSpecLanguageParser.AND, 0)

        def OR(self):
            return self.getToken(DeclSpecLanguageParser.OR, 0)

        def IMPL(self):
            return self.getToken(DeclSpecLanguageParser.IMPL, 0)

        def IFF(self):
            return self.getToken(DeclSpecLanguageParser.IFF, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_bool_binary_op

        def accept(self, visitor):
            if hasattr(visitor, "visitBool_binary_op"):
                return visitor.visitBool_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def bool_binary_op(self):

        localctx = DeclSpecLanguageParser.Bool_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bool_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.AND) | (1 << DeclSpecLanguageParser.OR) | (1 << DeclSpecLanguageParser.IMPL) | (1 << DeclSpecLanguageParser.IFF))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_binary_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Arith_binary_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(DeclSpecLanguageParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(DeclSpecLanguageParser.MINUS, 0)

        def TIMES(self):
            return self.getToken(DeclSpecLanguageParser.TIMES, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_arith_binary_op

        def accept(self, visitor):
            if hasattr(visitor, "visitArith_binary_op"):
                return visitor.visitArith_binary_op(self)
            else:
                return visitor.visitChildren(self)




    def arith_binary_op(self):

        localctx = DeclSpecLanguageParser.Arith_binary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arith_binary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.PLUS) | (1 << DeclSpecLanguageParser.MINUS) | (1 << DeclSpecLanguageParser.TIMES))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comparison_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.Comparison_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEQ(self):
            return self.getToken(DeclSpecLanguageParser.LEQ, 0)

        def EQ(self):
            return self.getToken(DeclSpecLanguageParser.EQ, 0)

        def GEQ(self):
            return self.getToken(DeclSpecLanguageParser.GEQ, 0)

        def LT(self):
            return self.getToken(DeclSpecLanguageParser.LT, 0)

        def GT(self):
            return self.getToken(DeclSpecLanguageParser.GT, 0)

        def NEQ(self):
            return self.getToken(DeclSpecLanguageParser.NEQ, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_comparison_op

        def accept(self, visitor):
            if hasattr(visitor, "visitComparison_op"):
                return visitor.visitComparison_op(self)
            else:
                return visitor.visitChildren(self)




    def comparison_op(self):

        localctx = DeclSpecLanguageParser.Comparison_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_comparison_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DeclSpecLanguageParser.LEQ) | (1 << DeclSpecLanguageParser.EQ) | (1 << DeclSpecLanguageParser.GEQ) | (1 << DeclSpecLanguageParser.LT) | (1 << DeclSpecLanguageParser.GT) | (1 << DeclSpecLanguageParser.NEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryOpContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.UnaryOpContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(DeclSpecLanguageParser.NOT, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_unaryOp

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryOp"):
                return visitor.visitUnaryOp(self)
            else:
                return visitor.visitChildren(self)




    def unaryOp(self):

        localctx = DeclSpecLanguageParser.UnaryOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_unaryOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(DeclSpecLanguageParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolFactContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(DeclSpecLanguageParser.BoolFactContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(DeclSpecLanguageParser.TRUE, 0)

        def getRuleIndex(self):
            return DeclSpecLanguageParser.RULE_boolFact

        def accept(self, visitor):
            if hasattr(visitor, "visitBoolFact"):
                return visitor.visitBoolFact(self)
            else:
                return visitor.visitChildren(self)




    def boolFact(self):

        localctx = DeclSpecLanguageParser.BoolFactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_boolFact)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(DeclSpecLanguageParser.TRUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





