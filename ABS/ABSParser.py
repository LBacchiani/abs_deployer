# Generated from /Users/lorenzobacchiani/Desktop/abs_deployer/ABS/ABS.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,108,1536,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,1,0,1,0,5,0,151,8,0,10,0,12,0,154,9,0,1,0,1,0,
        1,1,1,1,5,1,160,8,1,10,1,12,1,163,9,1,1,1,1,1,1,2,1,2,3,2,169,8,
        2,1,3,5,3,172,8,3,10,3,12,3,175,9,3,1,3,1,3,1,3,1,3,1,3,5,3,182,
        8,3,10,3,12,3,185,9,3,1,3,1,3,3,3,189,8,3,1,4,1,4,1,4,1,4,1,4,5,
        4,196,8,4,10,4,12,4,199,9,4,1,4,1,4,3,4,203,8,4,1,5,1,5,1,5,1,5,
        5,5,209,8,5,10,5,12,5,212,9,5,3,5,214,8,5,1,5,1,5,1,6,5,6,219,8,
        6,10,6,12,6,222,9,6,1,6,1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,3,9,233,
        8,9,1,10,1,10,1,10,1,10,1,10,1,10,3,10,241,8,10,1,10,1,10,1,10,1,
        10,1,10,1,10,3,10,249,8,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,
        10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,267,8,10,1,10,3,
        10,270,8,10,1,10,1,10,1,10,1,10,1,10,3,10,277,8,10,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        3,11,295,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,5,11,315,8,11,10,11,12,11,
        318,9,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,3,11,336,8,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        5,11,356,8,11,10,11,12,11,359,9,11,1,12,1,12,1,12,1,12,1,12,1,13,
        1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,5,13,375,8,13,10,13,12,13,
        378,9,13,3,13,380,8,13,1,13,3,13,383,8,13,3,13,385,8,13,1,14,1,14,
        3,14,389,8,14,1,14,1,14,1,15,1,15,1,15,5,15,396,8,15,10,15,12,15,
        399,9,15,3,15,401,8,15,1,16,1,16,1,16,1,16,5,16,407,8,16,10,16,12,
        16,410,9,16,1,16,1,16,1,17,1,17,1,17,1,17,3,17,418,8,17,1,17,1,17,
        1,17,1,18,5,18,424,8,18,10,18,12,18,427,9,18,1,18,1,18,1,18,1,18,
        3,18,433,8,18,1,18,1,18,1,18,5,18,438,8,18,10,18,12,18,441,9,18,
        1,18,1,18,1,18,1,18,1,18,1,18,5,18,449,8,18,10,18,12,18,452,9,18,
        1,18,1,18,1,18,5,18,457,8,18,10,18,12,18,460,9,18,1,18,1,18,1,18,
        1,18,1,18,5,18,467,8,18,10,18,12,18,470,9,18,1,18,1,18,1,18,1,18,
        1,18,5,18,477,8,18,10,18,12,18,480,9,18,1,18,1,18,5,18,484,8,18,
        10,18,12,18,487,9,18,1,18,1,18,5,18,491,8,18,10,18,12,18,494,9,18,
        1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,503,8,18,1,18,5,18,506,8,
        18,10,18,12,18,509,9,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,5,18,
        518,8,18,10,18,12,18,521,9,18,1,18,1,18,1,18,1,18,1,18,5,18,528,
        8,18,10,18,12,18,531,9,18,1,18,1,18,1,18,3,18,536,8,18,1,18,5,18,
        539,8,18,10,18,12,18,542,9,18,1,18,1,18,1,18,1,18,1,18,5,18,549,
        8,18,10,18,12,18,552,9,18,1,18,1,18,1,18,5,18,557,8,18,10,18,12,
        18,560,9,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,5,18,571,
        8,18,10,18,12,18,574,9,18,1,18,1,18,1,18,1,18,1,18,5,18,581,8,18,
        10,18,12,18,584,9,18,1,18,1,18,1,18,1,18,1,18,5,18,591,8,18,10,18,
        12,18,594,9,18,1,18,1,18,1,18,1,18,1,18,5,18,601,8,18,10,18,12,18,
        604,9,18,1,18,1,18,1,18,1,18,5,18,610,8,18,10,18,12,18,613,9,18,
        1,18,1,18,1,18,1,18,5,18,619,8,18,10,18,12,18,622,9,18,1,18,1,18,
        3,18,626,8,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,3,19,640,8,19,1,19,1,19,1,19,5,19,645,8,19,10,19,12,19,
        648,9,19,1,20,1,20,1,20,1,20,1,21,5,21,655,8,21,10,21,12,21,658,
        9,21,1,21,1,21,1,21,1,21,1,21,1,21,5,21,666,8,21,10,21,12,21,669,
        9,21,1,21,3,21,672,8,21,1,21,1,21,1,21,1,21,5,21,678,8,21,10,21,
        12,21,681,9,21,3,21,683,8,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,
        5,22,692,8,22,10,22,12,22,695,9,22,1,22,1,22,3,22,699,8,22,1,23,
        1,23,3,23,703,8,23,1,24,5,24,706,8,24,10,24,12,24,709,9,24,1,24,
        1,24,1,24,1,24,1,24,1,24,1,25,5,25,718,8,25,10,25,12,25,721,9,25,
        1,25,1,25,1,25,1,25,1,25,1,25,5,25,729,8,25,10,25,12,25,732,9,25,
        1,25,1,25,3,25,736,8,25,1,25,1,25,1,26,5,26,741,8,26,10,26,12,26,
        744,9,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,5,26,753,8,26,10,26,
        12,26,756,9,26,1,26,3,26,759,8,26,1,26,1,26,1,26,1,26,3,26,765,8,
        26,1,26,1,26,1,27,5,27,770,8,27,10,27,12,27,773,9,27,1,27,1,27,1,
        27,1,27,1,27,1,27,5,27,781,8,27,10,27,12,27,784,9,27,3,27,786,8,
        27,1,27,1,27,5,27,790,8,27,10,27,12,27,793,9,27,1,27,1,27,1,28,5,
        28,798,8,28,10,28,12,28,801,9,28,1,28,1,28,1,28,1,28,1,28,1,29,5,
        29,809,8,29,10,29,12,29,812,9,29,1,29,1,29,1,29,3,29,817,8,29,1,
        29,1,29,1,29,1,29,5,29,823,8,29,10,29,12,29,826,9,29,3,29,828,8,
        29,1,29,1,29,5,29,832,8,29,10,29,12,29,835,9,29,1,29,1,29,5,29,839,
        8,29,10,29,12,29,842,9,29,1,29,3,29,845,8,29,1,29,5,29,848,8,29,
        10,29,12,29,851,9,29,1,29,1,29,1,30,5,30,856,8,30,10,30,12,30,859,
        9,30,1,30,1,30,1,30,1,30,3,30,865,8,30,1,30,1,30,1,31,5,31,870,8,
        31,10,31,12,31,873,9,31,1,31,1,31,1,31,1,31,1,31,5,31,880,8,31,10,
        31,12,31,883,9,31,1,31,1,31,1,32,1,32,1,32,1,32,5,32,891,8,32,10,
        32,12,32,894,9,32,1,32,5,32,897,8,32,10,32,12,32,900,9,32,1,32,5,
        32,903,8,32,10,32,12,32,906,9,32,1,32,3,32,909,8,32,1,33,1,33,1,
        33,1,33,1,33,5,33,916,8,33,10,33,12,33,919,9,33,3,33,921,8,33,1,
        33,1,33,3,33,925,8,33,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,
        34,1,34,1,34,5,34,938,8,34,10,34,12,34,941,9,34,1,34,1,34,1,34,1,
        34,1,34,1,34,1,34,5,34,950,8,34,10,34,12,34,953,9,34,1,34,1,34,3,
        34,957,8,34,1,35,1,35,1,35,1,35,1,35,1,35,3,35,965,8,35,1,36,1,36,
        1,36,1,36,1,36,1,36,5,36,973,8,36,10,36,12,36,976,9,36,1,36,1,36,
        3,36,980,8,36,1,36,1,36,5,36,984,8,36,10,36,12,36,987,9,36,1,36,
        5,36,990,8,36,10,36,12,36,993,9,36,1,37,1,37,1,37,1,37,3,37,999,
        8,37,1,38,1,38,1,38,1,38,1,38,1,38,3,38,1007,8,38,1,39,1,39,1,39,
        1,39,1,40,1,40,1,40,3,40,1016,8,40,1,41,1,41,1,41,1,41,1,41,1,41,
        1,41,1,41,1,41,1,41,3,41,1028,8,41,1,42,1,42,1,42,1,42,1,42,1,42,
        1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,5,42,1044,8,42,10,42,12,
        42,1047,9,42,3,42,1049,8,42,1,42,1,42,1,42,1,42,5,42,1055,8,42,10,
        42,12,42,1058,9,42,3,42,1060,8,42,1,42,1,42,5,42,1064,8,42,10,42,
        12,42,1067,9,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
        1,42,1,42,1,42,1,42,5,42,1083,8,42,10,42,12,42,1086,9,42,1,42,1,
        42,3,42,1090,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
        43,3,43,1102,8,43,1,44,1,44,1,44,1,44,3,44,1108,8,44,1,45,1,45,1,
        45,1,45,3,45,1114,8,45,1,46,1,46,1,46,1,46,5,46,1120,8,46,10,46,
        12,46,1123,9,46,1,47,1,47,1,47,1,47,1,47,1,47,1,47,5,47,1132,8,47,
        10,47,12,47,1135,9,47,1,47,5,47,1138,8,47,10,47,12,47,1141,9,47,
        1,47,1,47,1,47,5,47,1146,8,47,10,47,12,47,1149,9,47,1,47,1,47,1,
        48,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,1,
        50,1,50,1,50,5,50,1169,8,50,10,50,12,50,1172,9,50,1,50,1,50,5,50,
        1176,8,50,10,50,12,50,1179,9,50,1,51,1,51,3,51,1183,8,51,1,51,1,
        51,1,51,1,51,5,51,1189,8,51,10,51,12,51,1192,9,51,1,51,1,51,3,51,
        1196,8,51,1,52,1,52,1,52,3,52,1201,8,52,1,52,3,52,1204,8,52,1,52,
        3,52,1207,8,52,1,52,1,52,1,53,1,53,1,53,1,53,1,53,5,53,1216,8,53,
        10,53,12,53,1219,9,53,1,53,1,53,3,53,1223,8,53,1,54,1,54,1,54,1,
        54,1,54,3,54,1230,8,54,1,55,1,55,1,55,1,55,5,55,1236,8,55,10,55,
        12,55,1239,9,55,1,56,1,56,1,56,1,57,1,57,1,57,1,58,1,58,1,58,1,58,
        1,58,1,58,1,58,1,58,3,58,1255,8,58,1,58,1,58,1,58,1,58,1,58,1,58,
        5,58,1263,8,58,10,58,12,58,1266,9,58,1,59,1,59,1,59,1,59,1,59,3,
        59,1273,8,59,1,60,1,60,1,60,1,60,1,60,1,60,5,60,1281,8,60,10,60,
        12,60,1284,9,60,3,60,1286,8,60,1,60,1,60,1,60,5,60,1291,8,60,10,
        60,12,60,1294,9,60,1,60,1,60,3,60,1298,8,60,1,61,1,61,1,61,1,61,
        1,61,5,61,1305,8,61,10,61,12,61,1308,9,61,1,61,1,61,1,61,1,61,1,
        62,1,62,1,62,3,62,1317,8,62,1,62,1,62,5,62,1321,8,62,10,62,12,62,
        1324,9,62,1,62,1,62,1,63,1,63,1,63,3,63,1331,8,63,1,63,1,63,5,63,
        1335,8,63,10,63,12,63,1338,9,63,1,63,3,63,1341,8,63,1,64,1,64,1,
        64,1,64,1,64,1,64,1,64,1,64,3,64,1351,8,64,1,64,3,64,1354,8,64,1,
        64,1,64,1,64,1,64,5,64,1360,8,64,10,64,12,64,1363,9,64,1,64,1,64,
        1,65,3,65,1368,8,65,1,65,1,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        5,66,1379,8,66,10,66,12,66,1382,9,66,1,66,1,66,1,66,1,66,1,66,1,
        66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,
        66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1409,8,66,1,67,1,67,3,67,1413,
        8,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,
        1,67,1,67,1,67,1,67,3,67,1431,8,67,1,68,1,68,1,68,1,68,1,68,1,68,
        1,68,1,68,1,68,1,68,1,68,1,68,1,68,3,68,1446,8,68,1,68,1,68,1,68,
        1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,
        1,68,1,68,1,68,1,68,1,68,5,68,1469,8,68,10,68,12,68,1472,9,68,1,
        69,1,69,3,69,1476,8,69,1,70,3,70,1479,8,70,1,70,1,70,1,71,5,71,1484,
        8,71,10,71,12,71,1487,9,71,1,71,1,71,5,71,1491,8,71,10,71,12,71,
        1494,9,71,1,71,1,71,1,72,5,72,1499,8,72,10,72,12,72,1502,9,72,1,
        72,5,72,1505,8,72,10,72,12,72,1508,9,72,1,72,5,72,1511,8,72,10,72,
        12,72,1514,9,72,1,72,3,72,1517,8,72,1,72,5,72,1520,8,72,10,72,12,
        72,1523,9,72,1,72,1,72,1,72,1,72,5,72,1529,8,72,10,72,12,72,1532,
        9,72,1,73,1,73,1,73,0,4,22,38,116,136,74,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
        138,140,142,144,146,0,9,1,0,92,94,1,0,95,97,2,0,94,94,98,98,1,0,
        99,102,1,0,105,106,1,0,71,72,1,0,92,93,1,0,93,94,1,0,107,108,1705,
        0,152,1,0,0,0,2,161,1,0,0,0,4,168,1,0,0,0,6,173,1,0,0,0,8,190,1,
        0,0,0,10,204,1,0,0,0,12,220,1,0,0,0,14,226,1,0,0,0,16,228,1,0,0,
        0,18,232,1,0,0,0,20,276,1,0,0,0,22,335,1,0,0,0,24,360,1,0,0,0,26,
        384,1,0,0,0,28,388,1,0,0,0,30,400,1,0,0,0,32,402,1,0,0,0,34,413,
        1,0,0,0,36,625,1,0,0,0,38,639,1,0,0,0,40,649,1,0,0,0,42,656,1,0,
        0,0,44,686,1,0,0,0,46,700,1,0,0,0,48,707,1,0,0,0,50,719,1,0,0,0,
        52,742,1,0,0,0,54,771,1,0,0,0,56,799,1,0,0,0,58,810,1,0,0,0,60,857,
        1,0,0,0,62,871,1,0,0,0,64,886,1,0,0,0,66,910,1,0,0,0,68,928,1,0,
        0,0,70,964,1,0,0,0,72,966,1,0,0,0,74,998,1,0,0,0,76,1006,1,0,0,0,
        78,1008,1,0,0,0,80,1015,1,0,0,0,82,1027,1,0,0,0,84,1089,1,0,0,0,
        86,1101,1,0,0,0,88,1107,1,0,0,0,90,1113,1,0,0,0,92,1115,1,0,0,0,
        94,1124,1,0,0,0,96,1152,1,0,0,0,98,1157,1,0,0,0,100,1161,1,0,0,0,
        102,1180,1,0,0,0,104,1197,1,0,0,0,106,1210,1,0,0,0,108,1229,1,0,
        0,0,110,1231,1,0,0,0,112,1240,1,0,0,0,114,1243,1,0,0,0,116,1254,
        1,0,0,0,118,1267,1,0,0,0,120,1274,1,0,0,0,122,1299,1,0,0,0,124,1313,
        1,0,0,0,126,1327,1,0,0,0,128,1342,1,0,0,0,130,1367,1,0,0,0,132,1408,
        1,0,0,0,134,1430,1,0,0,0,136,1445,1,0,0,0,138,1475,1,0,0,0,140,1478,
        1,0,0,0,142,1485,1,0,0,0,144,1500,1,0,0,0,146,1533,1,0,0,0,148,149,
        5,89,0,0,149,151,5,1,0,0,150,148,1,0,0,0,151,154,1,0,0,0,152,150,
        1,0,0,0,152,153,1,0,0,0,153,155,1,0,0,0,154,152,1,0,0,0,155,156,
        5,89,0,0,156,1,1,0,0,0,157,158,5,89,0,0,158,160,5,1,0,0,159,157,
        1,0,0,0,160,163,1,0,0,0,161,159,1,0,0,0,161,162,1,0,0,0,162,164,
        1,0,0,0,163,161,1,0,0,0,164,165,5,88,0,0,165,3,1,0,0,0,166,169,3,
        0,0,0,167,169,3,2,1,0,168,166,1,0,0,0,168,167,1,0,0,0,169,5,1,0,
        0,0,170,172,3,34,17,0,171,170,1,0,0,0,172,175,1,0,0,0,173,171,1,
        0,0,0,173,174,1,0,0,0,174,176,1,0,0,0,175,173,1,0,0,0,176,188,3,
        0,0,0,177,178,5,101,0,0,178,183,3,6,3,0,179,180,5,2,0,0,180,182,
        3,6,3,0,181,179,1,0,0,0,182,185,1,0,0,0,183,181,1,0,0,0,183,184,
        1,0,0,0,184,186,1,0,0,0,185,183,1,0,0,0,186,187,5,102,0,0,187,189,
        1,0,0,0,188,177,1,0,0,0,188,189,1,0,0,0,189,7,1,0,0,0,190,202,3,
        0,0,0,191,192,5,101,0,0,192,197,3,6,3,0,193,194,5,2,0,0,194,196,
        3,6,3,0,195,193,1,0,0,0,196,199,1,0,0,0,197,195,1,0,0,0,197,198,
        1,0,0,0,198,200,1,0,0,0,199,197,1,0,0,0,200,201,5,102,0,0,201,203,
        1,0,0,0,202,191,1,0,0,0,202,203,1,0,0,0,203,9,1,0,0,0,204,213,5,
        3,0,0,205,210,3,12,6,0,206,207,5,2,0,0,207,209,3,12,6,0,208,206,
        1,0,0,0,209,212,1,0,0,0,210,208,1,0,0,0,210,211,1,0,0,0,211,214,
        1,0,0,0,212,210,1,0,0,0,213,205,1,0,0,0,213,214,1,0,0,0,214,215,
        1,0,0,0,215,216,5,4,0,0,216,11,1,0,0,0,217,219,3,34,17,0,218,217,
        1,0,0,0,219,222,1,0,0,0,220,218,1,0,0,0,220,221,1,0,0,0,221,223,
        1,0,0,0,222,220,1,0,0,0,223,224,3,8,4,0,224,225,5,88,0,0,225,13,
        1,0,0,0,226,227,3,0,0,0,227,15,1,0,0,0,228,229,5,89,0,0,229,17,1,
        0,0,0,230,233,3,20,10,0,231,233,3,22,11,0,232,230,1,0,0,0,232,231,
        1,0,0,0,233,19,1,0,0,0,234,235,3,22,11,0,235,236,5,1,0,0,236,237,
        5,5,0,0,237,277,1,0,0,0,238,240,5,6,0,0,239,241,5,7,0,0,240,239,
        1,0,0,0,240,241,1,0,0,0,241,242,1,0,0,0,242,243,5,89,0,0,243,244,
        5,3,0,0,244,245,3,30,15,0,245,246,5,4,0,0,246,277,1,0,0,0,247,249,
        5,8,0,0,248,247,1,0,0,0,248,249,1,0,0,0,249,250,1,0,0,0,250,251,
        3,22,11,0,251,252,5,93,0,0,252,253,5,88,0,0,253,254,5,3,0,0,254,
        255,3,30,15,0,255,256,5,4,0,0,256,277,1,0,0,0,257,258,3,22,11,0,
        258,259,5,1,0,0,259,260,5,88,0,0,260,261,5,3,0,0,261,262,3,30,15,
        0,262,263,5,4,0,0,263,277,1,0,0,0,264,267,3,16,8,0,265,267,5,9,0,
        0,266,264,1,0,0,0,266,265,1,0,0,0,267,268,1,0,0,0,268,270,5,1,0,
        0,269,266,1,0,0,0,269,270,1,0,0,0,270,271,1,0,0,0,271,272,5,10,0,
        0,272,273,5,3,0,0,273,274,3,30,15,0,274,275,5,4,0,0,275,277,1,0,
        0,0,276,234,1,0,0,0,276,238,1,0,0,0,276,248,1,0,0,0,276,257,1,0,
        0,0,276,269,1,0,0,0,277,21,1,0,0,0,278,279,6,11,-1,0,279,280,3,2,
        1,0,280,281,5,3,0,0,281,282,3,30,15,0,282,283,5,4,0,0,283,336,1,
        0,0,0,284,285,3,2,1,0,285,286,5,11,0,0,286,287,3,30,15,0,287,288,
        5,12,0,0,288,336,1,0,0,0,289,294,3,0,0,0,290,291,5,3,0,0,291,292,
        3,30,15,0,292,293,5,4,0,0,293,295,1,0,0,0,294,290,1,0,0,0,294,295,
        1,0,0,0,295,336,1,0,0,0,296,297,7,0,0,0,297,336,3,22,11,16,298,336,
        3,28,14,0,299,336,5,90,0,0,300,336,5,91,0,0,301,336,5,13,0,0,302,
        336,5,14,0,0,303,304,5,15,0,0,304,305,3,22,11,0,305,306,5,16,0,0,
        306,307,3,22,11,0,307,308,5,17,0,0,308,309,3,22,11,4,309,336,1,0,
        0,0,310,311,5,18,0,0,311,312,3,22,11,0,312,316,5,19,0,0,313,315,
        3,24,12,0,314,313,1,0,0,0,315,318,1,0,0,0,316,314,1,0,0,0,316,317,
        1,0,0,0,317,319,1,0,0,0,318,316,1,0,0,0,319,320,5,20,0,0,320,336,
        1,0,0,0,321,322,5,21,0,0,322,323,5,3,0,0,323,324,3,6,3,0,324,325,
        5,88,0,0,325,326,5,4,0,0,326,327,5,22,0,0,327,328,3,22,11,0,328,
        329,5,23,0,0,329,330,3,22,11,2,330,336,1,0,0,0,331,332,5,3,0,0,332,
        333,3,22,11,0,333,334,5,4,0,0,334,336,1,0,0,0,335,278,1,0,0,0,335,
        284,1,0,0,0,335,289,1,0,0,0,335,296,1,0,0,0,335,298,1,0,0,0,335,
        299,1,0,0,0,335,300,1,0,0,0,335,301,1,0,0,0,335,302,1,0,0,0,335,
        303,1,0,0,0,335,310,1,0,0,0,335,321,1,0,0,0,335,331,1,0,0,0,336,
        357,1,0,0,0,337,338,10,15,0,0,338,339,7,1,0,0,339,356,3,22,11,16,
        340,341,10,14,0,0,341,342,7,2,0,0,342,356,3,22,11,15,343,344,10,
        13,0,0,344,345,7,3,0,0,345,356,3,22,11,14,346,347,10,12,0,0,347,
        348,7,4,0,0,348,356,3,22,11,13,349,350,10,11,0,0,350,351,5,103,0,
        0,351,356,3,22,11,12,352,353,10,10,0,0,353,354,5,104,0,0,354,356,
        3,22,11,11,355,337,1,0,0,0,355,340,1,0,0,0,355,343,1,0,0,0,355,346,
        1,0,0,0,355,349,1,0,0,0,355,352,1,0,0,0,356,359,1,0,0,0,357,355,
        1,0,0,0,357,358,1,0,0,0,358,23,1,0,0,0,359,357,1,0,0,0,360,361,3,
        26,13,0,361,362,5,24,0,0,362,363,3,22,11,0,363,364,5,25,0,0,364,
        25,1,0,0,0,365,385,5,26,0,0,366,385,5,90,0,0,367,385,5,91,0,0,368,
        385,5,88,0,0,369,382,3,0,0,0,370,379,5,3,0,0,371,376,3,26,13,0,372,
        373,5,2,0,0,373,375,3,26,13,0,374,372,1,0,0,0,375,378,1,0,0,0,376,
        374,1,0,0,0,376,377,1,0,0,0,377,380,1,0,0,0,378,376,1,0,0,0,379,
        371,1,0,0,0,379,380,1,0,0,0,380,381,1,0,0,0,381,383,5,4,0,0,382,
        370,1,0,0,0,382,383,1,0,0,0,383,385,1,0,0,0,384,365,1,0,0,0,384,
        366,1,0,0,0,384,367,1,0,0,0,384,368,1,0,0,0,384,369,1,0,0,0,385,
        27,1,0,0,0,386,387,5,13,0,0,387,389,5,1,0,0,388,386,1,0,0,0,388,
        389,1,0,0,0,389,390,1,0,0,0,390,391,5,88,0,0,391,29,1,0,0,0,392,
        397,3,22,11,0,393,394,5,2,0,0,394,396,3,22,11,0,395,393,1,0,0,0,
        396,399,1,0,0,0,397,395,1,0,0,0,397,398,1,0,0,0,398,401,1,0,0,0,
        399,397,1,0,0,0,400,392,1,0,0,0,400,401,1,0,0,0,401,31,1,0,0,0,402,
        403,5,11,0,0,403,408,3,22,11,0,404,405,5,2,0,0,405,407,3,22,11,0,
        406,404,1,0,0,0,407,410,1,0,0,0,408,406,1,0,0,0,408,409,1,0,0,0,
        409,411,1,0,0,0,410,408,1,0,0,0,411,412,5,12,0,0,412,33,1,0,0,0,
        413,417,5,11,0,0,414,415,3,6,3,0,415,416,5,27,0,0,416,418,1,0,0,
        0,417,414,1,0,0,0,417,418,1,0,0,0,418,419,1,0,0,0,419,420,3,22,11,
        0,420,421,5,12,0,0,421,35,1,0,0,0,422,424,3,34,17,0,423,422,1,0,
        0,0,424,427,1,0,0,0,425,423,1,0,0,0,425,426,1,0,0,0,426,428,1,0,
        0,0,427,425,1,0,0,0,428,429,3,8,4,0,429,432,5,88,0,0,430,431,5,22,
        0,0,431,433,3,18,9,0,432,430,1,0,0,0,432,433,1,0,0,0,433,434,1,0,
        0,0,434,435,5,25,0,0,435,626,1,0,0,0,436,438,3,34,17,0,437,436,1,
        0,0,0,438,441,1,0,0,0,439,437,1,0,0,0,439,440,1,0,0,0,440,442,1,
        0,0,0,441,439,1,0,0,0,442,443,3,28,14,0,443,444,5,22,0,0,444,445,
        3,18,9,0,445,446,5,25,0,0,446,626,1,0,0,0,447,449,3,34,17,0,448,
        447,1,0,0,0,449,452,1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,451,
        453,1,0,0,0,452,450,1,0,0,0,453,454,5,28,0,0,454,626,5,25,0,0,455,
        457,3,34,17,0,456,455,1,0,0,0,457,460,1,0,0,0,458,456,1,0,0,0,458,
        459,1,0,0,0,459,461,1,0,0,0,460,458,1,0,0,0,461,462,5,29,0,0,462,
        463,3,18,9,0,463,464,5,25,0,0,464,626,1,0,0,0,465,467,3,34,17,0,
        466,465,1,0,0,0,467,470,1,0,0,0,468,466,1,0,0,0,468,469,1,0,0,0,
        469,471,1,0,0,0,470,468,1,0,0,0,471,472,5,30,0,0,472,473,3,18,9,
        0,473,474,5,25,0,0,474,626,1,0,0,0,475,477,3,34,17,0,476,475,1,0,
        0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,481,1,0,
        0,0,480,478,1,0,0,0,481,485,5,19,0,0,482,484,3,36,18,0,483,482,1,
        0,0,0,484,487,1,0,0,0,485,483,1,0,0,0,485,486,1,0,0,0,486,488,1,
        0,0,0,487,485,1,0,0,0,488,626,5,20,0,0,489,491,3,34,17,0,490,489,
        1,0,0,0,491,494,1,0,0,0,492,490,1,0,0,0,492,493,1,0,0,0,493,495,
        1,0,0,0,494,492,1,0,0,0,495,496,5,15,0,0,496,497,5,3,0,0,497,498,
        3,22,11,0,498,499,5,4,0,0,499,502,3,36,18,0,500,501,5,17,0,0,501,
        503,3,36,18,0,502,500,1,0,0,0,502,503,1,0,0,0,503,626,1,0,0,0,504,
        506,3,34,17,0,505,504,1,0,0,0,506,509,1,0,0,0,507,505,1,0,0,0,507,
        508,1,0,0,0,508,510,1,0,0,0,509,507,1,0,0,0,510,511,5,31,0,0,511,
        512,5,3,0,0,512,513,3,22,11,0,513,514,5,4,0,0,514,515,3,36,18,0,
        515,626,1,0,0,0,516,518,3,34,17,0,517,516,1,0,0,0,518,521,1,0,0,
        0,519,517,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,519,1,0,0,
        0,522,523,5,32,0,0,523,524,3,36,18,0,524,525,5,33,0,0,525,529,5,
        19,0,0,526,528,3,40,20,0,527,526,1,0,0,0,528,531,1,0,0,0,529,527,
        1,0,0,0,529,530,1,0,0,0,530,532,1,0,0,0,531,529,1,0,0,0,532,535,
        5,20,0,0,533,534,5,34,0,0,534,536,3,36,18,0,535,533,1,0,0,0,535,
        536,1,0,0,0,536,626,1,0,0,0,537,539,3,34,17,0,538,537,1,0,0,0,539,
        542,1,0,0,0,540,538,1,0,0,0,540,541,1,0,0,0,541,543,1,0,0,0,542,
        540,1,0,0,0,543,544,5,8,0,0,544,545,3,38,19,0,545,546,5,25,0,0,546,
        626,1,0,0,0,547,549,3,34,17,0,548,547,1,0,0,0,549,552,1,0,0,0,550,
        548,1,0,0,0,550,551,1,0,0,0,551,553,1,0,0,0,552,550,1,0,0,0,553,
        554,5,35,0,0,554,626,5,25,0,0,555,557,3,34,17,0,556,555,1,0,0,0,
        557,560,1,0,0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,561,1,0,0,0,
        560,558,1,0,0,0,561,562,5,36,0,0,562,563,5,3,0,0,563,564,3,22,11,
        0,564,565,5,2,0,0,565,566,3,22,11,0,566,567,5,4,0,0,567,568,5,25,
        0,0,568,626,1,0,0,0,569,571,3,34,17,0,570,569,1,0,0,0,571,574,1,
        0,0,0,572,570,1,0,0,0,572,573,1,0,0,0,573,575,1,0,0,0,574,572,1,
        0,0,0,575,576,5,37,0,0,576,577,3,22,11,0,577,578,5,25,0,0,578,626,
        1,0,0,0,579,581,3,34,17,0,580,579,1,0,0,0,581,584,1,0,0,0,582,580,
        1,0,0,0,582,583,1,0,0,0,583,585,1,0,0,0,584,582,1,0,0,0,585,586,
        5,38,0,0,586,587,3,22,11,0,587,588,5,25,0,0,588,626,1,0,0,0,589,
        591,3,34,17,0,590,589,1,0,0,0,591,594,1,0,0,0,592,590,1,0,0,0,592,
        593,1,0,0,0,593,595,1,0,0,0,594,592,1,0,0,0,595,596,5,39,0,0,596,
        597,3,22,11,0,597,598,5,25,0,0,598,626,1,0,0,0,599,601,3,34,17,0,
        600,599,1,0,0,0,601,604,1,0,0,0,602,600,1,0,0,0,602,603,1,0,0,0,
        603,605,1,0,0,0,604,602,1,0,0,0,605,606,3,18,9,0,606,607,5,25,0,
        0,607,626,1,0,0,0,608,610,3,34,17,0,609,608,1,0,0,0,610,613,1,0,
        0,0,611,609,1,0,0,0,611,612,1,0,0,0,612,614,1,0,0,0,613,611,1,0,
        0,0,614,615,5,18,0,0,615,616,3,22,11,0,616,620,5,19,0,0,617,619,
        3,40,20,0,618,617,1,0,0,0,619,622,1,0,0,0,620,618,1,0,0,0,620,621,
        1,0,0,0,621,623,1,0,0,0,622,620,1,0,0,0,623,624,5,20,0,0,624,626,
        1,0,0,0,625,425,1,0,0,0,625,439,1,0,0,0,625,450,1,0,0,0,625,458,
        1,0,0,0,625,468,1,0,0,0,625,478,1,0,0,0,625,492,1,0,0,0,625,507,
        1,0,0,0,625,519,1,0,0,0,625,540,1,0,0,0,625,550,1,0,0,0,625,558,
        1,0,0,0,625,572,1,0,0,0,625,582,1,0,0,0,625,592,1,0,0,0,625,602,
        1,0,0,0,625,611,1,0,0,0,626,37,1,0,0,0,627,628,6,19,-1,0,628,629,
        3,28,14,0,629,630,5,40,0,0,630,640,1,0,0,0,631,632,5,36,0,0,632,
        633,5,3,0,0,633,634,3,22,11,0,634,635,5,2,0,0,635,636,3,22,11,0,
        636,637,5,4,0,0,637,640,1,0,0,0,638,640,3,22,11,0,639,627,1,0,0,
        0,639,631,1,0,0,0,639,638,1,0,0,0,640,646,1,0,0,0,641,642,10,1,0,
        0,642,643,5,41,0,0,643,645,3,38,19,2,644,641,1,0,0,0,645,648,1,0,
        0,0,646,644,1,0,0,0,646,647,1,0,0,0,647,39,1,0,0,0,648,646,1,0,0,
        0,649,650,3,26,13,0,650,651,5,24,0,0,651,652,3,36,18,0,652,41,1,
        0,0,0,653,655,3,34,17,0,654,653,1,0,0,0,655,658,1,0,0,0,656,654,
        1,0,0,0,656,657,1,0,0,0,657,659,1,0,0,0,658,656,1,0,0,0,659,660,
        5,42,0,0,660,671,5,89,0,0,661,662,5,101,0,0,662,667,5,89,0,0,663,
        664,5,2,0,0,664,666,5,89,0,0,665,663,1,0,0,0,666,669,1,0,0,0,667,
        665,1,0,0,0,667,668,1,0,0,0,668,670,1,0,0,0,669,667,1,0,0,0,670,
        672,5,102,0,0,671,661,1,0,0,0,671,672,1,0,0,0,672,682,1,0,0,0,673,
        674,5,22,0,0,674,679,3,44,22,0,675,676,5,43,0,0,676,678,3,44,22,
        0,677,675,1,0,0,0,678,681,1,0,0,0,679,677,1,0,0,0,679,680,1,0,0,
        0,680,683,1,0,0,0,681,679,1,0,0,0,682,673,1,0,0,0,682,683,1,0,0,
        0,683,684,1,0,0,0,684,685,5,25,0,0,685,43,1,0,0,0,686,698,5,89,0,
        0,687,688,5,3,0,0,688,693,3,46,23,0,689,690,5,2,0,0,690,692,3,46,
        23,0,691,689,1,0,0,0,692,695,1,0,0,0,693,691,1,0,0,0,693,694,1,0,
        0,0,694,696,1,0,0,0,695,693,1,0,0,0,696,697,5,4,0,0,697,699,1,0,
        0,0,698,687,1,0,0,0,698,699,1,0,0,0,699,45,1,0,0,0,700,702,3,6,3,
        0,701,703,5,88,0,0,702,701,1,0,0,0,702,703,1,0,0,0,703,47,1,0,0,
        0,704,706,3,34,17,0,705,704,1,0,0,0,706,709,1,0,0,0,707,705,1,0,
        0,0,707,708,1,0,0,0,708,710,1,0,0,0,709,707,1,0,0,0,710,711,5,44,
        0,0,711,712,5,89,0,0,712,713,5,22,0,0,713,714,3,6,3,0,714,715,5,
        25,0,0,715,49,1,0,0,0,716,718,3,34,17,0,717,716,1,0,0,0,718,721,
        1,0,0,0,719,717,1,0,0,0,719,720,1,0,0,0,720,722,1,0,0,0,721,719,
        1,0,0,0,722,723,5,45,0,0,723,735,5,89,0,0,724,725,5,3,0,0,725,730,
        3,46,23,0,726,727,5,2,0,0,727,729,3,46,23,0,728,726,1,0,0,0,729,
        732,1,0,0,0,730,728,1,0,0,0,730,731,1,0,0,0,731,733,1,0,0,0,732,
        730,1,0,0,0,733,734,5,4,0,0,734,736,1,0,0,0,735,724,1,0,0,0,735,
        736,1,0,0,0,736,737,1,0,0,0,737,738,5,25,0,0,738,51,1,0,0,0,739,
        741,3,34,17,0,740,739,1,0,0,0,741,744,1,0,0,0,742,740,1,0,0,0,742,
        743,1,0,0,0,743,745,1,0,0,0,744,742,1,0,0,0,745,746,5,46,0,0,746,
        747,3,6,3,0,747,758,5,88,0,0,748,749,5,101,0,0,749,754,5,89,0,0,
        750,751,5,2,0,0,751,753,5,89,0,0,752,750,1,0,0,0,753,756,1,0,0,0,
        754,752,1,0,0,0,754,755,1,0,0,0,755,757,1,0,0,0,756,754,1,0,0,0,
        757,759,5,102,0,0,758,748,1,0,0,0,758,759,1,0,0,0,759,760,1,0,0,
        0,760,761,3,10,5,0,761,764,5,22,0,0,762,765,5,47,0,0,763,765,3,22,
        11,0,764,762,1,0,0,0,764,763,1,0,0,0,765,766,1,0,0,0,766,767,5,25,
        0,0,767,53,1,0,0,0,768,770,3,34,17,0,769,768,1,0,0,0,770,773,1,0,
        0,0,771,769,1,0,0,0,771,772,1,0,0,0,772,774,1,0,0,0,773,771,1,0,
        0,0,774,775,5,48,0,0,775,785,3,0,0,0,776,777,5,49,0,0,777,782,3,
        14,7,0,778,779,5,2,0,0,779,781,3,14,7,0,780,778,1,0,0,0,781,784,
        1,0,0,0,782,780,1,0,0,0,782,783,1,0,0,0,783,786,1,0,0,0,784,782,
        1,0,0,0,785,776,1,0,0,0,785,786,1,0,0,0,786,787,1,0,0,0,787,791,
        5,19,0,0,788,790,3,56,28,0,789,788,1,0,0,0,790,793,1,0,0,0,791,789,
        1,0,0,0,791,792,1,0,0,0,792,794,1,0,0,0,793,791,1,0,0,0,794,795,
        5,20,0,0,795,55,1,0,0,0,796,798,3,34,17,0,797,796,1,0,0,0,798,801,
        1,0,0,0,799,797,1,0,0,0,799,800,1,0,0,0,800,802,1,0,0,0,801,799,
        1,0,0,0,802,803,3,6,3,0,803,804,5,88,0,0,804,805,3,10,5,0,805,806,
        5,25,0,0,806,57,1,0,0,0,807,809,3,34,17,0,808,807,1,0,0,0,809,812,
        1,0,0,0,810,808,1,0,0,0,810,811,1,0,0,0,811,813,1,0,0,0,812,810,
        1,0,0,0,813,814,5,50,0,0,814,816,3,0,0,0,815,817,3,10,5,0,816,815,
        1,0,0,0,816,817,1,0,0,0,817,827,1,0,0,0,818,819,5,51,0,0,819,824,
        3,14,7,0,820,821,5,2,0,0,821,823,3,14,7,0,822,820,1,0,0,0,823,826,
        1,0,0,0,824,822,1,0,0,0,824,825,1,0,0,0,825,828,1,0,0,0,826,824,
        1,0,0,0,827,818,1,0,0,0,827,828,1,0,0,0,828,829,1,0,0,0,829,833,
        5,19,0,0,830,832,3,60,30,0,831,830,1,0,0,0,832,835,1,0,0,0,833,831,
        1,0,0,0,833,834,1,0,0,0,834,844,1,0,0,0,835,833,1,0,0,0,836,840,
        5,19,0,0,837,839,3,36,18,0,838,837,1,0,0,0,839,842,1,0,0,0,840,838,
        1,0,0,0,840,841,1,0,0,0,841,843,1,0,0,0,842,840,1,0,0,0,843,845,
        5,20,0,0,844,836,1,0,0,0,844,845,1,0,0,0,845,849,1,0,0,0,846,848,
        3,62,31,0,847,846,1,0,0,0,848,851,1,0,0,0,849,847,1,0,0,0,849,850,
        1,0,0,0,850,852,1,0,0,0,851,849,1,0,0,0,852,853,5,20,0,0,853,59,
        1,0,0,0,854,856,3,34,17,0,855,854,1,0,0,0,856,859,1,0,0,0,857,855,
        1,0,0,0,857,858,1,0,0,0,858,860,1,0,0,0,859,857,1,0,0,0,860,861,
        3,6,3,0,861,864,5,88,0,0,862,863,5,22,0,0,863,865,3,22,11,0,864,
        862,1,0,0,0,864,865,1,0,0,0,865,866,1,0,0,0,866,867,5,25,0,0,867,
        61,1,0,0,0,868,870,3,34,17,0,869,868,1,0,0,0,870,873,1,0,0,0,871,
        869,1,0,0,0,871,872,1,0,0,0,872,874,1,0,0,0,873,871,1,0,0,0,874,
        875,3,6,3,0,875,876,5,88,0,0,876,877,3,10,5,0,877,881,5,19,0,0,878,
        880,3,36,18,0,879,878,1,0,0,0,880,883,1,0,0,0,881,879,1,0,0,0,881,
        882,1,0,0,0,882,884,1,0,0,0,883,881,1,0,0,0,884,885,5,20,0,0,885,
        63,1,0,0,0,886,887,5,52,0,0,887,888,3,0,0,0,888,892,5,25,0,0,889,
        891,3,66,33,0,890,889,1,0,0,0,891,894,1,0,0,0,892,890,1,0,0,0,892,
        893,1,0,0,0,893,898,1,0,0,0,894,892,1,0,0,0,895,897,3,68,34,0,896,
        895,1,0,0,0,897,900,1,0,0,0,898,896,1,0,0,0,898,899,1,0,0,0,899,
        904,1,0,0,0,900,898,1,0,0,0,901,903,3,70,35,0,902,901,1,0,0,0,903,
        906,1,0,0,0,904,902,1,0,0,0,904,905,1,0,0,0,905,908,1,0,0,0,906,
        904,1,0,0,0,907,909,3,142,71,0,908,907,1,0,0,0,908,909,1,0,0,0,909,
        65,1,0,0,0,910,920,5,53,0,0,911,921,5,95,0,0,912,917,3,4,2,0,913,
        914,5,2,0,0,914,916,3,4,2,0,915,913,1,0,0,0,916,919,1,0,0,0,917,
        915,1,0,0,0,917,918,1,0,0,0,918,921,1,0,0,0,919,917,1,0,0,0,920,
        911,1,0,0,0,920,912,1,0,0,0,921,924,1,0,0,0,922,923,5,54,0,0,923,
        925,3,0,0,0,924,922,1,0,0,0,924,925,1,0,0,0,925,926,1,0,0,0,926,
        927,5,25,0,0,927,67,1,0,0,0,928,956,5,55,0,0,929,930,5,95,0,0,930,
        931,5,54,0,0,931,932,3,0,0,0,932,933,5,25,0,0,933,957,1,0,0,0,934,
        939,3,4,2,0,935,936,5,2,0,0,936,938,3,4,2,0,937,935,1,0,0,0,938,
        941,1,0,0,0,939,937,1,0,0,0,939,940,1,0,0,0,940,942,1,0,0,0,941,
        939,1,0,0,0,942,943,5,54,0,0,943,944,3,0,0,0,944,945,5,25,0,0,945,
        957,1,0,0,0,946,951,3,4,2,0,947,948,5,2,0,0,948,950,3,4,2,0,949,
        947,1,0,0,0,950,953,1,0,0,0,951,949,1,0,0,0,951,952,1,0,0,0,952,
        954,1,0,0,0,953,951,1,0,0,0,954,955,5,25,0,0,955,957,1,0,0,0,956,
        929,1,0,0,0,956,934,1,0,0,0,956,946,1,0,0,0,957,69,1,0,0,0,958,965,
        3,42,21,0,959,965,3,52,26,0,960,965,3,48,24,0,961,965,3,50,25,0,
        962,965,3,54,27,0,963,965,3,58,29,0,964,958,1,0,0,0,964,959,1,0,
        0,0,964,960,1,0,0,0,964,961,1,0,0,0,964,962,1,0,0,0,964,963,1,0,
        0,0,965,71,1,0,0,0,966,967,5,56,0,0,967,979,5,89,0,0,968,969,5,3,
        0,0,969,974,3,74,37,0,970,971,5,2,0,0,971,973,3,74,37,0,972,970,
        1,0,0,0,973,976,1,0,0,0,974,972,1,0,0,0,974,975,1,0,0,0,975,977,
        1,0,0,0,976,974,1,0,0,0,977,978,5,4,0,0,978,980,1,0,0,0,979,968,
        1,0,0,0,979,980,1,0,0,0,980,981,1,0,0,0,981,985,5,25,0,0,982,984,
        3,78,39,0,983,982,1,0,0,0,984,987,1,0,0,0,985,983,1,0,0,0,985,986,
        1,0,0,0,986,991,1,0,0,0,987,985,1,0,0,0,988,990,3,80,40,0,989,988,
        1,0,0,0,990,993,1,0,0,0,991,989,1,0,0,0,991,992,1,0,0,0,992,73,1,
        0,0,0,993,991,1,0,0,0,994,999,3,12,6,0,995,996,3,0,0,0,996,997,3,
        76,38,0,997,999,1,0,0,0,998,994,1,0,0,0,998,995,1,0,0,0,999,75,1,
        0,0,0,1000,1001,5,57,0,0,1001,1007,3,60,30,0,1002,1003,5,58,0,0,
        1003,1007,3,56,28,0,1004,1005,5,59,0,0,1005,1007,3,14,7,0,1006,1000,
        1,0,0,0,1006,1002,1,0,0,0,1006,1004,1,0,0,0,1007,77,1,0,0,0,1008,
        1009,5,60,0,0,1009,1010,3,0,0,0,1010,1011,5,25,0,0,1011,79,1,0,0,
        0,1012,1016,3,82,41,0,1013,1016,3,84,42,0,1014,1016,3,90,45,0,1015,
        1012,1,0,0,0,1015,1013,1,0,0,0,1015,1014,1,0,0,0,1016,81,1,0,0,0,
        1017,1018,5,61,0,0,1018,1028,3,52,26,0,1019,1020,5,61,0,0,1020,1028,
        3,42,21,0,1021,1022,5,61,0,0,1022,1028,3,48,24,0,1023,1024,5,62,
        0,0,1024,1028,3,48,24,0,1025,1026,5,62,0,0,1026,1028,3,42,21,0,1027,
        1017,1,0,0,0,1027,1019,1,0,0,0,1027,1021,1,0,0,0,1027,1023,1,0,0,
        0,1027,1025,1,0,0,0,1028,83,1,0,0,0,1029,1030,5,61,0,0,1030,1090,
        3,58,29,0,1031,1032,5,63,0,0,1032,1033,5,50,0,0,1033,1034,3,0,0,
        0,1034,1035,5,25,0,0,1035,1090,1,0,0,0,1036,1037,5,62,0,0,1037,1038,
        5,50,0,0,1038,1048,3,0,0,0,1039,1040,5,61,0,0,1040,1045,3,14,7,0,
        1041,1042,5,2,0,0,1042,1044,3,14,7,0,1043,1041,1,0,0,0,1044,1047,
        1,0,0,0,1045,1043,1,0,0,0,1045,1046,1,0,0,0,1046,1049,1,0,0,0,1047,
        1045,1,0,0,0,1048,1039,1,0,0,0,1048,1049,1,0,0,0,1049,1059,1,0,0,
        0,1050,1051,5,63,0,0,1051,1056,3,14,7,0,1052,1053,5,2,0,0,1053,1055,
        3,14,7,0,1054,1052,1,0,0,0,1055,1058,1,0,0,0,1056,1054,1,0,0,0,1056,
        1057,1,0,0,0,1057,1060,1,0,0,0,1058,1056,1,0,0,0,1059,1050,1,0,0,
        0,1059,1060,1,0,0,0,1060,1061,1,0,0,0,1061,1065,5,19,0,0,1062,1064,
        3,86,43,0,1063,1062,1,0,0,0,1064,1067,1,0,0,0,1065,1063,1,0,0,0,
        1065,1066,1,0,0,0,1066,1068,1,0,0,0,1067,1065,1,0,0,0,1068,1069,
        5,20,0,0,1069,1090,1,0,0,0,1070,1071,5,61,0,0,1071,1090,3,54,27,
        0,1072,1073,5,63,0,0,1073,1074,5,48,0,0,1074,1075,3,0,0,0,1075,1076,
        5,25,0,0,1076,1090,1,0,0,0,1077,1078,5,62,0,0,1078,1079,5,48,0,0,
        1079,1080,3,0,0,0,1080,1084,5,19,0,0,1081,1083,3,88,44,0,1082,1081,
        1,0,0,0,1083,1086,1,0,0,0,1084,1082,1,0,0,0,1084,1085,1,0,0,0,1085,
        1087,1,0,0,0,1086,1084,1,0,0,0,1087,1088,5,20,0,0,1088,1090,1,0,
        0,0,1089,1029,1,0,0,0,1089,1031,1,0,0,0,1089,1036,1,0,0,0,1089,1070,
        1,0,0,0,1089,1072,1,0,0,0,1089,1077,1,0,0,0,1090,85,1,0,0,0,1091,
        1092,5,61,0,0,1092,1102,3,60,30,0,1093,1094,5,63,0,0,1094,1102,3,
        60,30,0,1095,1096,5,61,0,0,1096,1102,3,62,31,0,1097,1098,5,62,0,
        0,1098,1102,3,62,31,0,1099,1100,5,63,0,0,1100,1102,3,56,28,0,1101,
        1091,1,0,0,0,1101,1093,1,0,0,0,1101,1095,1,0,0,0,1101,1097,1,0,0,
        0,1101,1099,1,0,0,0,1102,87,1,0,0,0,1103,1104,5,61,0,0,1104,1108,
        3,56,28,0,1105,1106,5,63,0,0,1106,1108,3,56,28,0,1107,1103,1,0,0,
        0,1107,1105,1,0,0,0,1108,89,1,0,0,0,1109,1110,5,61,0,0,1110,1114,
        3,68,34,0,1111,1112,5,61,0,0,1112,1114,3,66,33,0,1113,1109,1,0,0,
        0,1113,1111,1,0,0,0,1114,91,1,0,0,0,1115,1116,5,64,0,0,1116,1117,
        5,89,0,0,1117,1121,5,25,0,0,1118,1120,3,94,47,0,1119,1118,1,0,0,
        0,1120,1123,1,0,0,0,1121,1119,1,0,0,0,1121,1122,1,0,0,0,1122,93,
        1,0,0,0,1123,1121,1,0,0,0,1124,1125,5,65,0,0,1125,1126,3,0,0,0,1126,
        1127,5,19,0,0,1127,1128,5,8,0,0,1128,1129,3,38,19,0,1129,1133,5,
        25,0,0,1130,1132,3,98,49,0,1131,1130,1,0,0,0,1132,1135,1,0,0,0,1133,
        1131,1,0,0,0,1133,1134,1,0,0,0,1134,1139,1,0,0,0,1135,1133,1,0,0,
        0,1136,1138,3,96,48,0,1137,1136,1,0,0,0,1138,1141,1,0,0,0,1139,1137,
        1,0,0,0,1139,1140,1,0,0,0,1140,1142,1,0,0,0,1141,1139,1,0,0,0,1142,
        1143,5,66,0,0,1143,1147,5,25,0,0,1144,1146,3,96,48,0,1145,1144,1,
        0,0,0,1146,1149,1,0,0,0,1147,1145,1,0,0,0,1147,1148,1,0,0,0,1148,
        1150,1,0,0,0,1149,1147,1,0,0,0,1150,1151,5,20,0,0,1151,95,1,0,0,
        0,1152,1153,3,28,14,0,1153,1154,5,22,0,0,1154,1155,3,18,9,0,1155,
        1156,5,25,0,0,1156,97,1,0,0,0,1157,1158,3,8,4,0,1158,1159,5,88,0,
        0,1159,1160,5,25,0,0,1160,99,1,0,0,0,1161,1162,5,67,0,0,1162,1163,
        5,89,0,0,1163,1164,5,25,0,0,1164,1165,5,68,0,0,1165,1170,3,102,51,
        0,1166,1167,5,2,0,0,1167,1169,3,102,51,0,1168,1166,1,0,0,0,1169,
        1172,1,0,0,0,1170,1168,1,0,0,0,1170,1171,1,0,0,0,1171,1173,1,0,0,
        0,1172,1170,1,0,0,0,1173,1177,5,25,0,0,1174,1176,3,104,52,0,1175,
        1174,1,0,0,0,1176,1179,1,0,0,0,1177,1175,1,0,0,0,1177,1178,1,0,0,
        0,1178,101,1,0,0,0,1179,1177,1,0,0,0,1180,1182,5,89,0,0,1181,1183,
        5,69,0,0,1182,1181,1,0,0,0,1182,1183,1,0,0,0,1183,1195,1,0,0,0,1184,
        1185,5,19,0,0,1185,1190,3,118,59,0,1186,1187,5,2,0,0,1187,1189,3,
        118,59,0,1188,1186,1,0,0,0,1189,1192,1,0,0,0,1190,1188,1,0,0,0,1190,
        1191,1,0,0,0,1191,1193,1,0,0,0,1192,1190,1,0,0,0,1193,1194,5,20,
        0,0,1194,1196,1,0,0,0,1195,1184,1,0,0,0,1195,1196,1,0,0,0,1196,103,
        1,0,0,0,1197,1198,5,56,0,0,1198,1200,3,106,53,0,1199,1201,3,110,
        55,0,1200,1199,1,0,0,0,1200,1201,1,0,0,0,1201,1203,1,0,0,0,1202,
        1204,3,112,56,0,1203,1202,1,0,0,0,1203,1204,1,0,0,0,1204,1206,1,
        0,0,0,1205,1207,3,114,57,0,1206,1205,1,0,0,0,1206,1207,1,0,0,0,1207,
        1208,1,0,0,0,1208,1209,5,25,0,0,1209,105,1,0,0,0,1210,1222,5,89,
        0,0,1211,1212,5,3,0,0,1212,1217,3,108,54,0,1213,1214,5,2,0,0,1214,
        1216,3,108,54,0,1215,1213,1,0,0,0,1216,1219,1,0,0,0,1217,1215,1,
        0,0,0,1217,1218,1,0,0,0,1218,1220,1,0,0,0,1219,1217,1,0,0,0,1220,
        1221,5,4,0,0,1221,1223,1,0,0,0,1222,1211,1,0,0,0,1222,1223,1,0,0,
        0,1223,107,1,0,0,0,1224,1225,5,89,0,0,1225,1226,5,1,0,0,1226,1230,
        5,88,0,0,1227,1230,5,90,0,0,1228,1230,5,89,0,0,1229,1224,1,0,0,0,
        1229,1227,1,0,0,0,1229,1228,1,0,0,0,1230,109,1,0,0,0,1231,1232,5,
        70,0,0,1232,1237,3,16,8,0,1233,1234,5,2,0,0,1234,1236,3,16,8,0,1235,
        1233,1,0,0,0,1236,1239,1,0,0,0,1237,1235,1,0,0,0,1237,1238,1,0,0,
        0,1238,111,1,0,0,0,1239,1237,1,0,0,0,1240,1241,5,54,0,0,1241,1242,
        3,116,58,0,1242,113,1,0,0,0,1243,1244,7,5,0,0,1244,1245,3,116,58,
        0,1245,115,1,0,0,0,1246,1247,6,58,-1,0,1247,1248,7,6,0,0,1248,1255,
        3,116,58,5,1249,1250,5,3,0,0,1250,1251,3,116,58,0,1251,1252,5,4,
        0,0,1252,1255,1,0,0,0,1253,1255,3,102,51,0,1254,1246,1,0,0,0,1254,
        1249,1,0,0,0,1254,1253,1,0,0,0,1255,1264,1,0,0,0,1256,1257,10,4,
        0,0,1257,1258,5,103,0,0,1258,1263,3,116,58,5,1259,1260,10,3,0,0,
        1260,1261,5,104,0,0,1261,1263,3,116,58,4,1262,1256,1,0,0,0,1262,
        1259,1,0,0,0,1263,1266,1,0,0,0,1264,1262,1,0,0,0,1264,1265,1,0,0,
        0,1265,117,1,0,0,0,1266,1264,1,0,0,0,1267,1268,5,88,0,0,1268,1272,
        5,22,0,0,1269,1273,5,90,0,0,1270,1273,5,89,0,0,1271,1273,5,91,0,
        0,1272,1269,1,0,0,0,1272,1270,1,0,0,0,1272,1271,1,0,0,0,1273,119,
        1,0,0,0,1274,1275,5,73,0,0,1275,1276,5,89,0,0,1276,1285,5,3,0,0,
        1277,1282,3,102,51,0,1278,1279,5,2,0,0,1279,1281,3,102,51,0,1280,
        1278,1,0,0,0,1281,1284,1,0,0,0,1282,1280,1,0,0,0,1282,1283,1,0,0,
        0,1283,1286,1,0,0,0,1284,1282,1,0,0,0,1285,1277,1,0,0,0,1285,1286,
        1,0,0,0,1286,1287,1,0,0,0,1287,1297,5,4,0,0,1288,1292,5,19,0,0,1289,
        1291,3,122,61,0,1290,1289,1,0,0,0,1291,1294,1,0,0,0,1292,1290,1,
        0,0,0,1292,1293,1,0,0,0,1293,1295,1,0,0,0,1294,1292,1,0,0,0,1295,
        1298,5,20,0,0,1296,1298,5,25,0,0,1297,1288,1,0,0,0,1297,1296,1,0,
        0,0,1298,121,1,0,0,0,1299,1300,5,89,0,0,1300,1301,5,56,0,0,1301,
        1306,3,16,8,0,1302,1303,5,2,0,0,1303,1305,3,16,8,0,1304,1302,1,0,
        0,0,1305,1308,1,0,0,0,1306,1304,1,0,0,0,1306,1307,1,0,0,0,1307,1309,
        1,0,0,0,1308,1306,1,0,0,0,1309,1310,5,64,0,0,1310,1311,5,89,0,0,
        1311,1312,5,25,0,0,1312,123,1,0,0,0,1313,1314,5,89,0,0,1314,1316,
        5,19,0,0,1315,1317,3,128,64,0,1316,1315,1,0,0,0,1316,1317,1,0,0,
        0,1317,1322,1,0,0,0,1318,1321,3,132,66,0,1319,1321,3,134,67,0,1320,
        1318,1,0,0,0,1320,1319,1,0,0,0,1321,1324,1,0,0,0,1322,1320,1,0,0,
        0,1322,1323,1,0,0,0,1323,1325,1,0,0,0,1324,1322,1,0,0,0,1325,1326,
        5,20,0,0,1326,125,1,0,0,0,1327,1340,5,89,0,0,1328,1330,5,19,0,0,
        1329,1331,3,128,64,0,1330,1329,1,0,0,0,1330,1331,1,0,0,0,1331,1336,
        1,0,0,0,1332,1335,3,132,66,0,1333,1335,3,134,67,0,1334,1332,1,0,
        0,0,1334,1333,1,0,0,0,1335,1338,1,0,0,0,1336,1334,1,0,0,0,1336,1337,
        1,0,0,0,1337,1339,1,0,0,0,1338,1336,1,0,0,0,1339,1341,5,20,0,0,1340,
        1328,1,0,0,0,1340,1341,1,0,0,0,1341,127,1,0,0,0,1342,1353,5,74,0,
        0,1343,1354,5,75,0,0,1344,1354,5,76,0,0,1345,1346,5,11,0,0,1346,
        1347,5,90,0,0,1347,1350,5,77,0,0,1348,1351,5,90,0,0,1349,1351,5,
        95,0,0,1350,1348,1,0,0,0,1350,1349,1,0,0,0,1351,1352,1,0,0,0,1352,
        1354,5,12,0,0,1353,1343,1,0,0,0,1353,1344,1,0,0,0,1353,1345,1,0,
        0,0,1354,1355,1,0,0,0,1355,1356,5,19,0,0,1356,1361,3,130,65,0,1357,
        1358,5,2,0,0,1358,1360,3,130,65,0,1359,1357,1,0,0,0,1360,1363,1,
        0,0,0,1361,1359,1,0,0,0,1361,1362,1,0,0,0,1362,1364,1,0,0,0,1363,
        1361,1,0,0,0,1364,1365,5,20,0,0,1365,129,1,0,0,0,1366,1368,5,78,
        0,0,1367,1366,1,0,0,0,1367,1368,1,0,0,0,1368,1369,1,0,0,0,1369,1370,
        3,126,63,0,1370,131,1,0,0,0,1371,1372,5,89,0,0,1372,1373,5,88,0,
        0,1373,1374,5,23,0,0,1374,1375,5,19,0,0,1375,1380,3,140,70,0,1376,
        1377,5,2,0,0,1377,1379,3,140,70,0,1378,1376,1,0,0,0,1379,1382,1,
        0,0,0,1380,1378,1,0,0,0,1380,1381,1,0,0,0,1381,1383,1,0,0,0,1382,
        1380,1,0,0,0,1383,1384,5,20,0,0,1384,1385,5,25,0,0,1385,1409,1,0,
        0,0,1386,1387,5,89,0,0,1387,1388,5,88,0,0,1388,1389,5,23,0,0,1389,
        1390,5,11,0,0,1390,1391,3,138,69,0,1391,1392,5,77,0,0,1392,1393,
        3,138,69,0,1393,1394,5,12,0,0,1394,1395,5,25,0,0,1395,1409,1,0,0,
        0,1396,1397,5,89,0,0,1397,1398,5,11,0,0,1398,1399,3,138,69,0,1399,
        1400,5,77,0,0,1400,1401,3,138,69,0,1401,1402,5,12,0,0,1402,1403,
        5,88,0,0,1403,1404,5,25,0,0,1404,1409,1,0,0,0,1405,1406,5,89,0,0,
        1406,1407,5,88,0,0,1407,1409,5,25,0,0,1408,1371,1,0,0,0,1408,1386,
        1,0,0,0,1408,1396,1,0,0,0,1408,1405,1,0,0,0,1409,133,1,0,0,0,1410,
        1411,5,79,0,0,1411,1413,5,27,0,0,1412,1410,1,0,0,0,1412,1413,1,0,
        0,0,1413,1414,1,0,0,0,1414,1415,3,136,68,0,1415,1416,5,25,0,0,1416,
        1431,1,0,0,0,1417,1418,5,80,0,0,1418,1419,5,27,0,0,1419,1420,3,136,
        68,0,1420,1421,5,25,0,0,1421,1431,1,0,0,0,1422,1423,5,81,0,0,1423,
        1424,5,27,0,0,1424,1425,5,89,0,0,1425,1431,5,25,0,0,1426,1427,5,
        82,0,0,1427,1428,5,27,0,0,1428,1429,5,89,0,0,1429,1431,5,25,0,0,
        1430,1412,1,0,0,0,1430,1417,1,0,0,0,1430,1422,1,0,0,0,1430,1426,
        1,0,0,0,1431,135,1,0,0,0,1432,1433,6,68,-1,0,1433,1434,5,89,0,0,
        1434,1435,5,1,0,0,1435,1446,5,88,0,0,1436,1446,5,89,0,0,1437,1446,
        5,90,0,0,1438,1446,5,88,0,0,1439,1440,7,7,0,0,1440,1446,3,136,68,
        9,1441,1442,5,3,0,0,1442,1443,3,136,68,0,1443,1444,5,4,0,0,1444,
        1446,1,0,0,0,1445,1432,1,0,0,0,1445,1436,1,0,0,0,1445,1437,1,0,0,
        0,1445,1438,1,0,0,0,1445,1439,1,0,0,0,1445,1441,1,0,0,0,1446,1470,
        1,0,0,0,1447,1448,10,8,0,0,1448,1449,7,1,0,0,1449,1469,3,136,68,
        9,1450,1451,10,7,0,0,1451,1452,7,2,0,0,1452,1469,3,136,68,8,1453,
        1454,10,6,0,0,1454,1455,7,3,0,0,1455,1469,3,136,68,7,1456,1457,10,
        5,0,0,1457,1458,7,4,0,0,1458,1469,3,136,68,6,1459,1460,10,4,0,0,
        1460,1461,7,8,0,0,1461,1469,3,136,68,5,1462,1463,10,3,0,0,1463,1464,
        5,103,0,0,1464,1469,3,136,68,4,1465,1466,10,2,0,0,1466,1467,5,104,
        0,0,1467,1469,3,136,68,3,1468,1447,1,0,0,0,1468,1450,1,0,0,0,1468,
        1453,1,0,0,0,1468,1456,1,0,0,0,1468,1459,1,0,0,0,1468,1462,1,0,0,
        0,1468,1465,1,0,0,0,1469,1472,1,0,0,0,1470,1468,1,0,0,0,1470,1471,
        1,0,0,0,1471,137,1,0,0,0,1472,1470,1,0,0,0,1473,1476,5,95,0,0,1474,
        1476,3,140,70,0,1475,1473,1,0,0,0,1475,1474,1,0,0,0,1476,139,1,0,
        0,0,1477,1479,5,94,0,0,1478,1477,1,0,0,0,1478,1479,1,0,0,0,1479,
        1480,1,0,0,0,1480,1481,5,90,0,0,1481,141,1,0,0,0,1482,1484,3,34,
        17,0,1483,1482,1,0,0,0,1484,1487,1,0,0,0,1485,1483,1,0,0,0,1485,
        1486,1,0,0,0,1486,1488,1,0,0,0,1487,1485,1,0,0,0,1488,1492,5,19,
        0,0,1489,1491,3,36,18,0,1490,1489,1,0,0,0,1491,1494,1,0,0,0,1492,
        1490,1,0,0,0,1492,1493,1,0,0,0,1493,1495,1,0,0,0,1494,1492,1,0,0,
        0,1495,1496,5,20,0,0,1496,143,1,0,0,0,1497,1499,3,64,32,0,1498,1497,
        1,0,0,0,1499,1502,1,0,0,0,1500,1498,1,0,0,0,1500,1501,1,0,0,0,1501,
        1506,1,0,0,0,1502,1500,1,0,0,0,1503,1505,3,72,36,0,1504,1503,1,0,
        0,0,1505,1508,1,0,0,0,1506,1504,1,0,0,0,1506,1507,1,0,0,0,1507,1512,
        1,0,0,0,1508,1506,1,0,0,0,1509,1511,3,92,46,0,1510,1509,1,0,0,0,
        1511,1514,1,0,0,0,1512,1510,1,0,0,0,1512,1513,1,0,0,0,1513,1516,
        1,0,0,0,1514,1512,1,0,0,0,1515,1517,3,100,50,0,1516,1515,1,0,0,0,
        1516,1517,1,0,0,0,1517,1521,1,0,0,0,1518,1520,3,120,60,0,1519,1518,
        1,0,0,0,1520,1523,1,0,0,0,1521,1519,1,0,0,0,1521,1522,1,0,0,0,1522,
        1530,1,0,0,0,1523,1521,1,0,0,0,1524,1525,5,83,0,0,1525,1529,3,126,
        63,0,1526,1527,5,84,0,0,1527,1529,3,124,62,0,1528,1524,1,0,0,0,1528,
        1526,1,0,0,0,1529,1532,1,0,0,0,1530,1528,1,0,0,0,1530,1531,1,0,0,
        0,1531,145,1,0,0,0,1532,1530,1,0,0,0,1533,1534,3,144,72,0,1534,147,
        1,0,0,0,173,152,161,168,173,183,188,197,202,210,213,220,232,240,
        248,266,269,276,294,316,335,355,357,376,379,382,384,388,397,400,
        408,417,425,432,439,450,458,468,478,485,492,502,507,519,529,535,
        540,550,558,572,582,592,602,611,620,625,639,646,656,667,671,679,
        682,693,698,702,707,719,730,735,742,754,758,764,771,782,785,791,
        799,810,816,824,827,833,840,844,849,857,864,871,881,892,898,904,
        908,917,920,924,939,951,956,964,974,979,985,991,998,1006,1015,1027,
        1045,1048,1056,1059,1065,1084,1089,1101,1107,1113,1121,1133,1139,
        1147,1170,1177,1182,1190,1195,1200,1203,1206,1217,1222,1229,1237,
        1254,1262,1264,1272,1282,1285,1292,1297,1306,1316,1320,1322,1330,
        1334,1336,1340,1350,1353,1361,1367,1380,1408,1412,1430,1445,1468,
        1470,1475,1478,1485,1492,1500,1506,1512,1516,1521,1528,1530
    ]

class ABSParser ( Parser ):

    grammarFileName = "ABS.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "','", "'('", "')'", "'get'", "'new'", 
                     "'local'", "'await'", "'core'", "'original'", "'['", 
                     "']'", "'this'", "'null'", "'if'", "'then'", "'else'", 
                     "'case'", "'{'", "'}'", "'let'", "'='", "'in'", "'=>'", 
                     "';'", "'_'", "':'", "'skip'", "'return'", "'assert'", 
                     "'while'", "'try'", "'catch'", "'finally'", "'suspend'", 
                     "'duration'", "'throw'", "'die'", "'movecogto'", "'?'", 
                     "'&'", "'data'", "'|'", "'type'", "'exception'", "'def'", 
                     "'builtin'", "'interface'", "'extends'", "'class'", 
                     "'implements'", "'module'", "'export'", "'from'", "'import'", 
                     "'delta'", "'hasField'", "'hasMethod'", "'hasInterface'", 
                     "'uses'", "'adds'", "'modifies'", "'removes'", "'stateupdate'", 
                     "'objectupdate'", "'classupdate'", "'productline'", 
                     "'features'", "'''", "'after'", "'when'", "'to'", "'product'", 
                     "'group'", "'oneof'", "'allof'", "'..'", "'opt'", "'ifin'", 
                     "'ifout'", "'exclude'", "'require'", "'root'", "'extension'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'~'", "'!'", 
                     "'-'", "'*'", "'/'", "'%'", "'+'", "'<='", "'>='", 
                     "'<'", "'>'", "'&&'", "'||'", "'=='", "'!='", "'->'", 
                     "'<->'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "TraditionalComment", "EndOfLineComment", 
                      "WhiteSpace", "IDENTIFIER", "TYPE_IDENTIFIER", "INTLITERAL", 
                      "STRINGLITERAL", "NEGATION_CREOL", "NEGATION", "MINUS", 
                      "MULT", "DIV", "MOD", "PLUS", "LTEQ", "GTEQ", "LT", 
                      "GT", "ANDAND", "OROR", "EQEQ", "NOTEQ", "IMPLIES", 
                      "EQUIV" ]

    RULE_qualified_type_identifier = 0
    RULE_qualified_identifier = 1
    RULE_any_identifier = 2
    RULE_type_use = 3
    RULE_type_exp = 4
    RULE_paramlist = 5
    RULE_param_decl = 6
    RULE_interface_name = 7
    RULE_delta_id = 8
    RULE_exp = 9
    RULE_eff_exp = 10
    RULE_pure_exp = 11
    RULE_casebranch = 12
    RULE_pattern = 13
    RULE_var_or_field_ref = 14
    RULE_pure_exp_list = 15
    RULE_list_literal = 16
    RULE_annotation = 17
    RULE_stmt = 18
    RULE_guard = 19
    RULE_casestmtbranch = 20
    RULE_datatype_decl = 21
    RULE_data_constructor = 22
    RULE_data_constructor_arg = 23
    RULE_typesyn_decl = 24
    RULE_exception_decl = 25
    RULE_function_decl = 26
    RULE_interface_decl = 27
    RULE_methodsig = 28
    RULE_class_decl = 29
    RULE_field_decl = 30
    RULE_method = 31
    RULE_module_decl = 32
    RULE_module_export = 33
    RULE_module_import = 34
    RULE_decl = 35
    RULE_delta_decl = 36
    RULE_delta_param = 37
    RULE_has_condition = 38
    RULE_delta_access = 39
    RULE_module_modifier = 40
    RULE_functional_modifier = 41
    RULE_oo_modifier = 42
    RULE_class_modifier_fragment = 43
    RULE_interface_modifier_fragment = 44
    RULE_namespace_modifier = 45
    RULE_update_decl = 46
    RULE_object_update = 47
    RULE_object_update_assign_stmt = 48
    RULE_update_preamble_decl = 49
    RULE_productline_decl = 50
    RULE_feature = 51
    RULE_delta_clause = 52
    RULE_deltaspec = 53
    RULE_deltaspec_param = 54
    RULE_after_condition = 55
    RULE_from_condition = 56
    RULE_when_condition = 57
    RULE_application_condition = 58
    RULE_attr_assignment = 59
    RULE_product_decl = 60
    RULE_product_reconfiguration = 61
    RULE_fextension = 62
    RULE_feature_decl = 63
    RULE_feature_decl_group = 64
    RULE_fnode = 65
    RULE_feature_decl_attribute = 66
    RULE_feature_decl_constraint = 67
    RULE_mexp = 68
    RULE_boundary_int = 69
    RULE_boundary_val = 70
    RULE_main_block = 71
    RULE_compilation_unit = 72
    RULE_goal = 73

    ruleNames =  [ "qualified_type_identifier", "qualified_identifier", 
                   "any_identifier", "type_use", "type_exp", "paramlist", 
                   "param_decl", "interface_name", "delta_id", "exp", "eff_exp", 
                   "pure_exp", "casebranch", "pattern", "var_or_field_ref", 
                   "pure_exp_list", "list_literal", "annotation", "stmt", 
                   "guard", "casestmtbranch", "datatype_decl", "data_constructor", 
                   "data_constructor_arg", "typesyn_decl", "exception_decl", 
                   "function_decl", "interface_decl", "methodsig", "class_decl", 
                   "field_decl", "method", "module_decl", "module_export", 
                   "module_import", "decl", "delta_decl", "delta_param", 
                   "has_condition", "delta_access", "module_modifier", "functional_modifier", 
                   "oo_modifier", "class_modifier_fragment", "interface_modifier_fragment", 
                   "namespace_modifier", "update_decl", "object_update", 
                   "object_update_assign_stmt", "update_preamble_decl", 
                   "productline_decl", "feature", "delta_clause", "deltaspec", 
                   "deltaspec_param", "after_condition", "from_condition", 
                   "when_condition", "application_condition", "attr_assignment", 
                   "product_decl", "product_reconfiguration", "fextension", 
                   "feature_decl", "feature_decl_group", "fnode", "feature_decl_attribute", 
                   "feature_decl_constraint", "mexp", "boundary_int", "boundary_val", 
                   "main_block", "compilation_unit", "goal" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    TraditionalComment=85
    EndOfLineComment=86
    WhiteSpace=87
    IDENTIFIER=88
    TYPE_IDENTIFIER=89
    INTLITERAL=90
    STRINGLITERAL=91
    NEGATION_CREOL=92
    NEGATION=93
    MINUS=94
    MULT=95
    DIV=96
    MOD=97
    PLUS=98
    LTEQ=99
    GTEQ=100
    LT=101
    GT=102
    ANDAND=103
    OROR=104
    EQEQ=105
    NOTEQ=106
    IMPLIES=107
    EQUIV=108

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Qualified_type_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.TYPE_IDENTIFIER)
            else:
                return self.getToken(ABSParser.TYPE_IDENTIFIER, i)

        def getRuleIndex(self):
            return ABSParser.RULE_qualified_type_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_type_identifier" ):
                listener.enterQualified_type_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_type_identifier" ):
                listener.exitQualified_type_identifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_type_identifier" ):
                return visitor.visitQualified_type_identifier(self)
            else:
                return visitor.visitChildren(self)




    def qualified_type_identifier(self):

        localctx = ABSParser.Qualified_type_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_qualified_type_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 148
                    self.match(ABSParser.TYPE_IDENTIFIER)
                    self.state = 149
                    self.match(ABSParser.T__0) 
                self.state = 154
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 155
            self.match(ABSParser.TYPE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualified_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def TYPE_IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.TYPE_IDENTIFIER)
            else:
                return self.getToken(ABSParser.TYPE_IDENTIFIER, i)

        def getRuleIndex(self):
            return ABSParser.RULE_qualified_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_identifier" ):
                listener.enterQualified_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_identifier" ):
                listener.exitQualified_identifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_identifier" ):
                return visitor.visitQualified_identifier(self)
            else:
                return visitor.visitChildren(self)




    def qualified_identifier(self):

        localctx = ABSParser.Qualified_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_qualified_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==89:
                self.state = 157
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 158
                self.match(ABSParser.T__0)
                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 164
            self.match(ABSParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def qualified_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_identifierContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_any_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAny_identifier" ):
                listener.enterAny_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAny_identifier" ):
                listener.exitAny_identifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAny_identifier" ):
                return visitor.visitAny_identifier(self)
            else:
                return visitor.visitChildren(self)




    def any_identifier(self):

        localctx = ABSParser.Any_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_any_identifier)
        try:
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 166
                self.qualified_type_identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 167
                self.qualified_identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_useContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Qualified_type_identifierContext
            self._type_use = None # Type_useContext
            self.p = list() # of Type_useContexts

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def LT(self):
            return self.getToken(ABSParser.LT, 0)

        def GT(self):
            return self.getToken(ABSParser.GT, 0)

        def type_use(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Type_useContext)
            else:
                return self.getTypedRuleContext(ABSParser.Type_useContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_type_use

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_use" ):
                listener.enterType_use(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_use" ):
                listener.exitType_use(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_use" ):
                return visitor.visitType_use(self)
            else:
                return visitor.visitChildren(self)




    def type_use(self):

        localctx = ABSParser.Type_useContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_type_use)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 170
                self.annotation()
                self.state = 175
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 176
            localctx.n = self.qualified_type_identifier()
            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==101:
                self.state = 177
                self.match(ABSParser.LT)
                self.state = 178
                localctx._type_use = self.type_use()
                localctx.p.append(localctx._type_use)
                self.state = 183
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 179
                    self.match(ABSParser.T__1)
                    self.state = 180
                    localctx._type_use = self.type_use()
                    localctx.p.append(localctx._type_use)
                    self.state = 185
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 186
                self.match(ABSParser.GT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_expContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Qualified_type_identifierContext
            self._type_use = None # Type_useContext
            self.p = list() # of Type_useContexts

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def LT(self):
            return self.getToken(ABSParser.LT, 0)

        def GT(self):
            return self.getToken(ABSParser.GT, 0)

        def type_use(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Type_useContext)
            else:
                return self.getTypedRuleContext(ABSParser.Type_useContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_type_exp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_exp" ):
                listener.enterType_exp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_exp" ):
                listener.exitType_exp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_exp" ):
                return visitor.visitType_exp(self)
            else:
                return visitor.visitChildren(self)




    def type_exp(self):

        localctx = ABSParser.Type_expContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_type_exp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            localctx.n = self.qualified_type_identifier()
            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==101:
                self.state = 191
                self.match(ABSParser.LT)
                self.state = 192
                localctx._type_use = self.type_use()
                localctx.p.append(localctx._type_use)
                self.state = 197
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 193
                    self.match(ABSParser.T__1)
                    self.state = 194
                    localctx._type_use = self.type_use()
                    localctx.p.append(localctx._type_use)
                    self.state = 199
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 200
                self.match(ABSParser.GT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamlistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def param_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Param_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Param_declContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_paramlist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamlist" ):
                listener.enterParamlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamlist" ):
                listener.exitParamlist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamlist" ):
                return visitor.visitParamlist(self)
            else:
                return visitor.visitChildren(self)




    def paramlist(self):

        localctx = ABSParser.ParamlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_paramlist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(ABSParser.T__2)
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11 or _la==89:
                self.state = 205
                self.param_decl()
                self.state = 210
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 206
                    self.match(ABSParser.T__1)
                    self.state = 207
                    self.param_decl()
                    self.state = 212
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 215
            self.match(ABSParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Param_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_exp(self):
            return self.getTypedRuleContext(ABSParser.Type_expContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_param_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParam_decl" ):
                listener.enterParam_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParam_decl" ):
                listener.exitParam_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParam_decl" ):
                return visitor.visitParam_decl(self)
            else:
                return visitor.visitChildren(self)




    def param_decl(self):

        localctx = ABSParser.Param_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_param_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 217
                self.annotation()
                self.state = 222
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 223
            self.type_exp()
            self.state = 224
            self.match(ABSParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_interface_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_name" ):
                listener.enterInterface_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_name" ):
                listener.exitInterface_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_name" ):
                return visitor.visitInterface_name(self)
            else:
                return visitor.visitChildren(self)




    def interface_name(self):

        localctx = ABSParser.Interface_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_interface_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.qualified_type_identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delta_idContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_delta_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelta_id" ):
                listener.enterDelta_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelta_id" ):
                listener.exitDelta_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelta_id" ):
                return visitor.visitDelta_id(self)
            else:
                return visitor.visitChildren(self)




    def delta_id(self):

        localctx = ABSParser.Delta_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_delta_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(ABSParser.TYPE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_exp

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class EffExpContext(ExpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.ExpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def eff_exp(self):
            return self.getTypedRuleContext(ABSParser.Eff_expContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffExp" ):
                listener.enterEffExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffExp" ):
                listener.exitEffExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEffExp" ):
                return visitor.visitEffExp(self)
            else:
                return visitor.visitChildren(self)


    class PureExpContext(ExpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.ExpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPureExp" ):
                listener.enterPureExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPureExp" ):
                listener.exitPureExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPureExp" ):
                return visitor.visitPureExp(self)
            else:
                return visitor.visitChildren(self)



    def exp(self):

        localctx = ABSParser.ExpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_exp)
        try:
            self.state = 232
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = ABSParser.EffExpContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 230
                self.eff_exp()
                pass

            elif la_ == 2:
                localctx = ABSParser.PureExpContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 231
                self.pure_exp(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Eff_expContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_eff_exp

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SyncCallExpContext(Eff_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Eff_expContext
            super().__init__(parser)
            self.o = None # Pure_expContext
            self.m = None # Token
            self.copyFrom(ctx)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSyncCallExp" ):
                listener.enterSyncCallExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSyncCallExp" ):
                listener.exitSyncCallExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSyncCallExp" ):
                return visitor.visitSyncCallExp(self)
            else:
                return visitor.visitChildren(self)


    class AsyncCallExpContext(Eff_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Eff_expContext
            super().__init__(parser)
            self.a = None # Token
            self.o = None # Pure_expContext
            self.m = None # Token
            self.copyFrom(ctx)

        def NEGATION(self):
            return self.getToken(ABSParser.NEGATION, 0)
        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsyncCallExp" ):
                listener.enterAsyncCallExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsyncCallExp" ):
                listener.exitAsyncCallExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsyncCallExp" ):
                return visitor.visitAsyncCallExp(self)
            else:
                return visitor.visitChildren(self)


    class GetExpContext(Eff_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Eff_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetExp" ):
                listener.enterGetExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetExp" ):
                listener.exitGetExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetExp" ):
                return visitor.visitGetExp(self)
            else:
                return visitor.visitChildren(self)


    class OriginalCallExpContext(Eff_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Eff_expContext
            super().__init__(parser)
            self.d = None # Delta_idContext
            self.c = None # Token
            self.copyFrom(ctx)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)

        def delta_id(self):
            return self.getTypedRuleContext(ABSParser.Delta_idContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOriginalCallExp" ):
                listener.enterOriginalCallExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOriginalCallExp" ):
                listener.exitOriginalCallExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOriginalCallExp" ):
                return visitor.visitOriginalCallExp(self)
            else:
                return visitor.visitChildren(self)


    class NewExpContext(Eff_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Eff_expContext
            super().__init__(parser)
            self.l = None # Token
            self.c = None # Token
            self.copyFrom(ctx)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNewExp" ):
                listener.enterNewExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNewExp" ):
                listener.exitNewExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNewExp" ):
                return visitor.visitNewExp(self)
            else:
                return visitor.visitChildren(self)



    def eff_exp(self):

        localctx = ABSParser.Eff_expContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_eff_exp)
        self._la = 0 # Token type
        try:
            self.state = 276
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                localctx = ABSParser.GetExpContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 234
                self.pure_exp(0)
                self.state = 235
                self.match(ABSParser.T__0)
                self.state = 236
                self.match(ABSParser.T__4)
                pass

            elif la_ == 2:
                localctx = ABSParser.NewExpContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 238
                self.match(ABSParser.T__5)
                self.state = 240
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==7:
                    self.state = 239
                    localctx.l = self.match(ABSParser.T__6)


                self.state = 242
                localctx.c = self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 243
                self.match(ABSParser.T__2)
                self.state = 244
                self.pure_exp_list()
                self.state = 245
                self.match(ABSParser.T__3)
                pass

            elif la_ == 3:
                localctx = ABSParser.AsyncCallExpContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 248
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8:
                    self.state = 247
                    localctx.a = self.match(ABSParser.T__7)


                self.state = 250
                localctx.o = self.pure_exp(0)
                self.state = 251
                self.match(ABSParser.NEGATION)
                self.state = 252
                localctx.m = self.match(ABSParser.IDENTIFIER)
                self.state = 253
                self.match(ABSParser.T__2)
                self.state = 254
                self.pure_exp_list()
                self.state = 255
                self.match(ABSParser.T__3)
                pass

            elif la_ == 4:
                localctx = ABSParser.SyncCallExpContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 257
                localctx.o = self.pure_exp(0)
                self.state = 258
                self.match(ABSParser.T__0)
                self.state = 259
                localctx.m = self.match(ABSParser.IDENTIFIER)
                self.state = 260
                self.match(ABSParser.T__2)
                self.state = 261
                self.pure_exp_list()
                self.state = 262
                self.match(ABSParser.T__3)
                pass

            elif la_ == 5:
                localctx = ABSParser.OriginalCallExpContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 269
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==9 or _la==89:
                    self.state = 266
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [89]:
                        self.state = 264
                        localctx.d = self.delta_id()
                        pass
                    elif token in [9]:
                        self.state = 265
                        localctx.c = self.match(ABSParser.T__8)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 268
                    self.match(ABSParser.T__0)


                self.state = 271
                self.match(ABSParser.T__9)
                self.state = 272
                self.match(ABSParser.T__2)
                self.state = 273
                self.pure_exp_list()
                self.state = 274
                self.match(ABSParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pure_expContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_pure_exp

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ConstructorExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorExp" ):
                listener.enterConstructorExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorExp" ):
                listener.exitConstructorExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructorExp" ):
                return visitor.visitConstructorExp(self)
            else:
                return visitor.visitChildren(self)


    class FunctionExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_identifierContext,0)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExp" ):
                listener.enterFunctionExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExp" ):
                listener.exitFunctionExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionExp" ):
                return visitor.visitFunctionExp(self)
            else:
                return visitor.visitChildren(self)


    class AndExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def ANDAND(self):
            return self.getToken(ABSParser.ANDAND, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndExp" ):
                listener.enterAndExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndExp" ):
                listener.exitAndExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndExp" ):
                return visitor.visitAndExp(self)
            else:
                return visitor.visitChildren(self)


    class GreaterExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def LT(self):
            return self.getToken(ABSParser.LT, 0)
        def GT(self):
            return self.getToken(ABSParser.GT, 0)
        def LTEQ(self):
            return self.getToken(ABSParser.LTEQ, 0)
        def GTEQ(self):
            return self.getToken(ABSParser.GTEQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGreaterExp" ):
                listener.enterGreaterExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGreaterExp" ):
                listener.exitGreaterExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGreaterExp" ):
                return visitor.visitGreaterExp(self)
            else:
                return visitor.visitChildren(self)


    class MultExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)
        def DIV(self):
            return self.getToken(ABSParser.DIV, 0)
        def MOD(self):
            return self.getToken(ABSParser.MOD, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultExp" ):
                listener.enterMultExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultExp" ):
                listener.exitMultExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultExp" ):
                return visitor.visitMultExp(self)
            else:
                return visitor.visitChildren(self)


    class VarOrFieldExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def var_or_field_ref(self):
            return self.getTypedRuleContext(ABSParser.Var_or_field_refContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarOrFieldExp" ):
                listener.enterVarOrFieldExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarOrFieldExp" ):
                listener.exitVarOrFieldExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarOrFieldExp" ):
                return visitor.visitVarOrFieldExp(self)
            else:
                return visitor.visitChildren(self)


    class StringExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRINGLITERAL(self):
            return self.getToken(ABSParser.STRINGLITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExp" ):
                listener.enterStringExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExp" ):
                listener.exitStringExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExp" ):
                return visitor.visitStringExp(self)
            else:
                return visitor.visitChildren(self)


    class CaseExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.c = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def casebranch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.CasebranchContext)
            else:
                return self.getTypedRuleContext(ABSParser.CasebranchContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExp" ):
                listener.enterCaseExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExp" ):
                listener.exitCaseExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExp" ):
                return visitor.visitCaseExp(self)
            else:
                return visitor.visitChildren(self)


    class AddExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def PLUS(self):
            return self.getToken(ABSParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(ABSParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddExp" ):
                listener.enterAddExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddExp" ):
                listener.exitAddExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddExp" ):
                return visitor.visitAddExp(self)
            else:
                return visitor.visitChildren(self)


    class NullExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullExp" ):
                listener.enterNullExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullExp" ):
                listener.exitNullExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullExp" ):
                return visitor.visitNullExp(self)
            else:
                return visitor.visitChildren(self)


    class EqualExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def EQEQ(self):
            return self.getToken(ABSParser.EQEQ, 0)
        def NOTEQ(self):
            return self.getToken(ABSParser.NOTEQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualExp" ):
                listener.enterEqualExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualExp" ):
                listener.exitEqualExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqualExp" ):
                return visitor.visitEqualExp(self)
            else:
                return visitor.visitChildren(self)


    class VariadicFunctionExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_identifierContext,0)

        def pure_exp_list(self):
            return self.getTypedRuleContext(ABSParser.Pure_exp_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariadicFunctionExp" ):
                listener.enterVariadicFunctionExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariadicFunctionExp" ):
                listener.exitVariadicFunctionExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariadicFunctionExp" ):
                return visitor.visitVariadicFunctionExp(self)
            else:
                return visitor.visitChildren(self)


    class IfExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.c = None # Pure_expContext
            self.l = None # Pure_expContext
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExp" ):
                listener.enterIfExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExp" ):
                listener.exitIfExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExp" ):
                return visitor.visitIfExp(self)
            else:
                return visitor.visitChildren(self)


    class OrExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.l = None # Pure_expContext
            self.op = None # Token
            self.r = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def OROR(self):
            return self.getToken(ABSParser.OROR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrExp" ):
                listener.enterOrExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrExp" ):
                listener.exitOrExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrExp" ):
                return visitor.visitOrExp(self)
            else:
                return visitor.visitChildren(self)


    class ParenExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExp" ):
                listener.enterParenExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExp" ):
                listener.exitParenExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExp" ):
                return visitor.visitParenExp(self)
            else:
                return visitor.visitChildren(self)


    class LetExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.i = None # Pure_expContext
            self.b = None # Pure_expContext
            self.copyFrom(ctx)

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)
        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetExp" ):
                listener.enterLetExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetExp" ):
                listener.exitLetExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetExp" ):
                return visitor.visitLetExp(self)
            else:
                return visitor.visitChildren(self)


    class UnaryExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def NEGATION(self):
            return self.getToken(ABSParser.NEGATION, 0)
        def NEGATION_CREOL(self):
            return self.getToken(ABSParser.NEGATION_CREOL, 0)
        def MINUS(self):
            return self.getToken(ABSParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryExp" ):
                listener.enterUnaryExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryExp" ):
                listener.exitUnaryExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryExp" ):
                return visitor.visitUnaryExp(self)
            else:
                return visitor.visitChildren(self)


    class IntExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntExp" ):
                listener.enterIntExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntExp" ):
                listener.exitIntExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntExp" ):
                return visitor.visitIntExp(self)
            else:
                return visitor.visitChildren(self)


    class ThisExpContext(Pure_expContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Pure_expContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThisExp" ):
                listener.enterThisExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThisExp" ):
                listener.exitThisExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThisExp" ):
                return visitor.visitThisExp(self)
            else:
                return visitor.visitChildren(self)



    def pure_exp(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ABSParser.Pure_expContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 22
        self.enterRecursionRule(localctx, 22, self.RULE_pure_exp, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                localctx = ABSParser.FunctionExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 279
                self.qualified_identifier()
                self.state = 280
                self.match(ABSParser.T__2)
                self.state = 281
                self.pure_exp_list()
                self.state = 282
                self.match(ABSParser.T__3)
                pass

            elif la_ == 2:
                localctx = ABSParser.VariadicFunctionExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 284
                self.qualified_identifier()
                self.state = 285
                self.match(ABSParser.T__10)
                self.state = 286
                self.pure_exp_list()
                self.state = 287
                self.match(ABSParser.T__11)
                pass

            elif la_ == 3:
                localctx = ABSParser.ConstructorExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 289
                self.qualified_type_identifier()
                self.state = 294
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 290
                    self.match(ABSParser.T__2)
                    self.state = 291
                    self.pure_exp_list()
                    self.state = 292
                    self.match(ABSParser.T__3)


                pass

            elif la_ == 4:
                localctx = ABSParser.UnaryExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 296
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 92)) & ~0x3f) == 0 and ((1 << (_la - 92)) & 7) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 297
                self.pure_exp(16)
                pass

            elif la_ == 5:
                localctx = ABSParser.VarOrFieldExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 298
                self.var_or_field_ref()
                pass

            elif la_ == 6:
                localctx = ABSParser.IntExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 299
                self.match(ABSParser.INTLITERAL)
                pass

            elif la_ == 7:
                localctx = ABSParser.StringExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 300
                self.match(ABSParser.STRINGLITERAL)
                pass

            elif la_ == 8:
                localctx = ABSParser.ThisExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 301
                self.match(ABSParser.T__12)
                pass

            elif la_ == 9:
                localctx = ABSParser.NullExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 302
                self.match(ABSParser.T__13)
                pass

            elif la_ == 10:
                localctx = ABSParser.IfExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 303
                self.match(ABSParser.T__14)
                self.state = 304
                localctx.c = self.pure_exp(0)
                self.state = 305
                self.match(ABSParser.T__15)
                self.state = 306
                localctx.l = self.pure_exp(0)
                self.state = 307
                self.match(ABSParser.T__16)
                self.state = 308
                localctx.r = self.pure_exp(4)
                pass

            elif la_ == 11:
                localctx = ABSParser.CaseExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 310
                self.match(ABSParser.T__17)
                self.state = 311
                localctx.c = self.pure_exp(0)
                self.state = 312
                self.match(ABSParser.T__18)
                self.state = 316
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==26 or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0):
                    self.state = 313
                    self.casebranch()
                    self.state = 318
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 319
                self.match(ABSParser.T__19)
                pass

            elif la_ == 12:
                localctx = ABSParser.LetExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 321
                self.match(ABSParser.T__20)
                self.state = 322
                self.match(ABSParser.T__2)
                self.state = 323
                self.type_use()
                self.state = 324
                self.match(ABSParser.IDENTIFIER)
                self.state = 325
                self.match(ABSParser.T__3)
                self.state = 326
                self.match(ABSParser.T__21)
                self.state = 327
                localctx.i = self.pure_exp(0)
                self.state = 328
                self.match(ABSParser.T__22)
                self.state = 329
                localctx.b = self.pure_exp(2)
                pass

            elif la_ == 13:
                localctx = ABSParser.ParenExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 331
                self.match(ABSParser.T__2)
                self.state = 332
                self.pure_exp(0)
                self.state = 333
                self.match(ABSParser.T__3)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 357
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 355
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                    if la_ == 1:
                        localctx = ABSParser.MultExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 337
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 338
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 7) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 339
                        localctx.r = self.pure_exp(16)
                        pass

                    elif la_ == 2:
                        localctx = ABSParser.AddExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 340
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 341
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==94 or _la==98):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 342
                        localctx.r = self.pure_exp(15)
                        pass

                    elif la_ == 3:
                        localctx = ABSParser.GreaterExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 343
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 344
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 99)) & ~0x3f) == 0 and ((1 << (_la - 99)) & 15) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 345
                        localctx.r = self.pure_exp(14)
                        pass

                    elif la_ == 4:
                        localctx = ABSParser.EqualExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 346
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 347
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==105 or _la==106):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 348
                        localctx.r = self.pure_exp(13)
                        pass

                    elif la_ == 5:
                        localctx = ABSParser.AndExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 349
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 350
                        localctx.op = self.match(ABSParser.ANDAND)
                        self.state = 351
                        localctx.r = self.pure_exp(12)
                        pass

                    elif la_ == 6:
                        localctx = ABSParser.OrExpContext(self, ABSParser.Pure_expContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_pure_exp)
                        self.state = 352
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 353
                        localctx.op = self.match(ABSParser.OROR)
                        self.state = 354
                        localctx.r = self.pure_exp(11)
                        pass

             
                self.state = 359
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CasebranchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self):
            return self.getTypedRuleContext(ABSParser.PatternContext,0)


        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_casebranch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCasebranch" ):
                listener.enterCasebranch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCasebranch" ):
                listener.exitCasebranch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCasebranch" ):
                return visitor.visitCasebranch(self)
            else:
                return visitor.visitChildren(self)




    def casebranch(self):

        localctx = ABSParser.CasebranchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_casebranch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.pattern()
            self.state = 361
            self.match(ABSParser.T__23)
            self.state = 362
            self.pure_exp(0)
            self.state = 363
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_pattern

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IntPatternContext(PatternContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.PatternContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntPattern" ):
                listener.enterIntPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntPattern" ):
                listener.exitIntPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntPattern" ):
                return visitor.visitIntPattern(self)
            else:
                return visitor.visitChildren(self)


    class VarPatternContext(PatternContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.PatternContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarPattern" ):
                listener.enterVarPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarPattern" ):
                listener.exitVarPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarPattern" ):
                return visitor.visitVarPattern(self)
            else:
                return visitor.visitChildren(self)


    class StringPatternContext(PatternContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.PatternContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRINGLITERAL(self):
            return self.getToken(ABSParser.STRINGLITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringPattern" ):
                listener.enterStringPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringPattern" ):
                listener.exitStringPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringPattern" ):
                return visitor.visitStringPattern(self)
            else:
                return visitor.visitChildren(self)


    class UnderscorePatternContext(PatternContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.PatternContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnderscorePattern" ):
                listener.enterUnderscorePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnderscorePattern" ):
                listener.exitUnderscorePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnderscorePattern" ):
                return visitor.visitUnderscorePattern(self)
            else:
                return visitor.visitChildren(self)


    class ConstructorPatternContext(PatternContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.PatternContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.PatternContext)
            else:
                return self.getTypedRuleContext(ABSParser.PatternContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorPattern" ):
                listener.enterConstructorPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorPattern" ):
                listener.exitConstructorPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructorPattern" ):
                return visitor.visitConstructorPattern(self)
            else:
                return visitor.visitChildren(self)



    def pattern(self):

        localctx = ABSParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.state = 384
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                localctx = ABSParser.UnderscorePatternContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 365
                self.match(ABSParser.T__25)
                pass
            elif token in [90]:
                localctx = ABSParser.IntPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 366
                self.match(ABSParser.INTLITERAL)
                pass
            elif token in [91]:
                localctx = ABSParser.StringPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 367
                self.match(ABSParser.STRINGLITERAL)
                pass
            elif token in [88]:
                localctx = ABSParser.VarPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 368
                self.match(ABSParser.IDENTIFIER)
                pass
            elif token in [89]:
                localctx = ABSParser.ConstructorPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 369
                self.qualified_type_identifier()
                self.state = 382
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==3:
                    self.state = 370
                    self.match(ABSParser.T__2)
                    self.state = 379
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==26 or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0):
                        self.state = 371
                        self.pattern()
                        self.state = 376
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==2:
                            self.state = 372
                            self.match(ABSParser.T__1)
                            self.state = 373
                            self.pattern()
                            self.state = 378
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 381
                    self.match(ABSParser.T__3)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_or_field_refContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_var_or_field_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_or_field_ref" ):
                listener.enterVar_or_field_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_or_field_ref" ):
                listener.exitVar_or_field_ref(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_or_field_ref" ):
                return visitor.visitVar_or_field_ref(self)
            else:
                return visitor.visitChildren(self)




    def var_or_field_ref(self):

        localctx = ABSParser.Var_or_field_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_var_or_field_ref)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 386
                self.match(ABSParser.T__12)
                self.state = 387
                self.match(ABSParser.T__0)


            self.state = 390
            self.match(ABSParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pure_exp_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_pure_exp_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPure_exp_list" ):
                listener.enterPure_exp_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPure_exp_list" ):
                listener.exitPure_exp_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPure_exp_list" ):
                return visitor.visitPure_exp_list(self)
            else:
                return visitor.visitChildren(self)




    def pure_exp_list(self):

        localctx = ABSParser.Pure_exp_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_pure_exp_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2416648) != 0) or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 127) != 0):
                self.state = 392
                self.pure_exp(0)
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 393
                    self.match(ABSParser.T__1)
                    self.state = 394
                    self.pure_exp(0)
                    self.state = 399
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_list_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_literal" ):
                listener.enterList_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_literal" ):
                listener.exitList_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList_literal" ):
                return visitor.visitList_literal(self)
            else:
                return visitor.visitChildren(self)




    def list_literal(self):

        localctx = ABSParser.List_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_list_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(ABSParser.T__10)
            self.state = 403
            self.pure_exp(0)
            self.state = 408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 404
                self.match(ABSParser.T__1)
                self.state = 405
                self.pure_exp(0)
                self.state = 410
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 411
            self.match(ABSParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.l = None # Type_useContext
            self.r = None # Pure_expContext

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_annotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation" ):
                listener.enterAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation" ):
                listener.exitAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation" ):
                return visitor.visitAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def annotation(self):

        localctx = ABSParser.AnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_annotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(ABSParser.T__10)
            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 414
                localctx.l = self.type_use()
                self.state = 415
                self.match(ABSParser.T__26)


            self.state = 419
            localctx.r = self.pure_exp(0)
            self.state = 420
            self.match(ABSParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_stmt

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExpStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpStmt" ):
                listener.enterExpStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpStmt" ):
                listener.exitExpStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpStmt" ):
                return visitor.visitExpStmt(self)
            else:
                return visitor.visitChildren(self)


    class AwaitStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def guard(self):
            return self.getTypedRuleContext(ABSParser.GuardContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAwaitStmt" ):
                listener.enterAwaitStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAwaitStmt" ):
                listener.exitAwaitStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAwaitStmt" ):
                return visitor.visitAwaitStmt(self)
            else:
                return visitor.visitChildren(self)


    class DieStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDieStmt" ):
                listener.enterDieStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDieStmt" ):
                listener.exitDieStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDieStmt" ):
                return visitor.visitDieStmt(self)
            else:
                return visitor.visitChildren(self)


    class TryCatchFinallyStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.b = None # StmtContext
            self.f = None # StmtContext
            self.copyFrom(ctx)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)

        def casestmtbranch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.CasestmtbranchContext)
            else:
                return self.getTypedRuleContext(ABSParser.CasestmtbranchContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryCatchFinallyStmt" ):
                listener.enterTryCatchFinallyStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryCatchFinallyStmt" ):
                listener.exitTryCatchFinallyStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTryCatchFinallyStmt" ):
                return visitor.visitTryCatchFinallyStmt(self)
            else:
                return visitor.visitChildren(self)


    class AssignStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def var_or_field_ref(self):
            return self.getTypedRuleContext(ABSParser.Var_or_field_refContext,0)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignStmt" ):
                listener.enterAssignStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignStmt" ):
                listener.exitAssignStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignStmt" ):
                return visitor.visitAssignStmt(self)
            else:
                return visitor.visitChildren(self)


    class BlockStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStmt" ):
                listener.enterBlockStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStmt" ):
                listener.exitBlockStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockStmt" ):
                return visitor.visitBlockStmt(self)
            else:
                return visitor.visitChildren(self)


    class CaseStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.c = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)

        def casestmtbranch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.CasestmtbranchContext)
            else:
                return self.getTypedRuleContext(ABSParser.CasestmtbranchContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStmt" ):
                listener.enterCaseStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStmt" ):
                listener.exitCaseStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseStmt" ):
                return visitor.visitCaseStmt(self)
            else:
                return visitor.visitChildren(self)


    class VardeclStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_exp(self):
            return self.getTypedRuleContext(ABSParser.Type_expContext,0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)
        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVardeclStmt" ):
                listener.enterVardeclStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVardeclStmt" ):
                listener.exitVardeclStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVardeclStmt" ):
                return visitor.visitVardeclStmt(self)
            else:
                return visitor.visitChildren(self)


    class SuspendStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuspendStmt" ):
                listener.enterSuspendStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuspendStmt" ):
                listener.exitSuspendStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSuspendStmt" ):
                return visitor.visitSuspendStmt(self)
            else:
                return visitor.visitChildren(self)


    class DurationStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.f = None # Pure_expContext
            self.t = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDurationStmt" ):
                listener.enterDurationStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDurationStmt" ):
                listener.exitDurationStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDurationStmt" ):
                return visitor.visitDurationStmt(self)
            else:
                return visitor.visitChildren(self)


    class IfStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.c = None # Pure_expContext
            self.l = None # StmtContext
            self.r = None # StmtContext
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStmt" ):
                listener.enterIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStmt" ):
                listener.exitIfStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStmt" ):
                return visitor.visitIfStmt(self)
            else:
                return visitor.visitChildren(self)


    class WhileStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.c = None # Pure_expContext
            self.copyFrom(ctx)

        def stmt(self):
            return self.getTypedRuleContext(ABSParser.StmtContext,0)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStmt" ):
                listener.enterWhileStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStmt" ):
                listener.exitWhileStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStmt" ):
                return visitor.visitWhileStmt(self)
            else:
                return visitor.visitChildren(self)


    class MoveCogToStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoveCogToStmt" ):
                listener.enterMoveCogToStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoveCogToStmt" ):
                listener.exitMoveCogToStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMoveCogToStmt" ):
                return visitor.visitMoveCogToStmt(self)
            else:
                return visitor.visitChildren(self)


    class AssertStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertStmt" ):
                listener.enterAssertStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertStmt" ):
                listener.exitAssertStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertStmt" ):
                return visitor.visitAssertStmt(self)
            else:
                return visitor.visitChildren(self)


    class SkipStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkipStmt" ):
                listener.enterSkipStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkipStmt" ):
                listener.exitSkipStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkipStmt" ):
                return visitor.visitSkipStmt(self)
            else:
                return visitor.visitChildren(self)


    class ReturnStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStmt" ):
                listener.enterReturnStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStmt" ):
                listener.exitReturnStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStmt" ):
                return visitor.visitReturnStmt(self)
            else:
                return visitor.visitChildren(self)


    class ThrowStmtContext(StmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.StmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThrowStmt" ):
                listener.enterThrowStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThrowStmt" ):
                listener.exitThrowStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThrowStmt" ):
                return visitor.visitThrowStmt(self)
            else:
                return visitor.visitChildren(self)



    def stmt(self):

        localctx = ABSParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_stmt)
        self._la = 0 # Token type
        try:
            self.state = 625
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                localctx = ABSParser.VardeclStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 422
                    self.annotation()
                    self.state = 427
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 428
                self.type_exp()
                self.state = 429
                self.match(ABSParser.IDENTIFIER)
                self.state = 432
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==22:
                    self.state = 430
                    self.match(ABSParser.T__21)
                    self.state = 431
                    self.exp()


                self.state = 434
                self.match(ABSParser.T__24)
                pass

            elif la_ == 2:
                localctx = ABSParser.AssignStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 439
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 436
                    self.annotation()
                    self.state = 441
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 442
                self.var_or_field_ref()
                self.state = 443
                self.match(ABSParser.T__21)
                self.state = 444
                self.exp()
                self.state = 445
                self.match(ABSParser.T__24)
                pass

            elif la_ == 3:
                localctx = ABSParser.SkipStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 447
                    self.annotation()
                    self.state = 452
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 453
                self.match(ABSParser.T__27)
                self.state = 454
                self.match(ABSParser.T__24)
                pass

            elif la_ == 4:
                localctx = ABSParser.ReturnStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 458
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 455
                    self.annotation()
                    self.state = 460
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 461
                self.match(ABSParser.T__28)
                self.state = 462
                self.exp()
                self.state = 463
                self.match(ABSParser.T__24)
                pass

            elif la_ == 5:
                localctx = ABSParser.AssertStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 468
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 465
                    self.annotation()
                    self.state = 470
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 471
                self.match(ABSParser.T__29)
                self.state = 472
                self.exp()
                self.state = 473
                self.match(ABSParser.T__24)
                pass

            elif la_ == 6:
                localctx = ABSParser.BlockStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 478
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 475
                    self.annotation()
                    self.state = 480
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 481
                self.match(ABSParser.T__18)
                self.state = 485
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1073476333384) != 0) or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 127) != 0):
                    self.state = 482
                    self.stmt()
                    self.state = 487
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 488
                self.match(ABSParser.T__19)
                pass

            elif la_ == 7:
                localctx = ABSParser.IfStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 492
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 489
                    self.annotation()
                    self.state = 494
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 495
                self.match(ABSParser.T__14)
                self.state = 496
                self.match(ABSParser.T__2)
                self.state = 497
                localctx.c = self.pure_exp(0)
                self.state = 498
                self.match(ABSParser.T__3)
                self.state = 499
                localctx.l = self.stmt()
                self.state = 502
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
                if la_ == 1:
                    self.state = 500
                    self.match(ABSParser.T__16)
                    self.state = 501
                    localctx.r = self.stmt()


                pass

            elif la_ == 8:
                localctx = ABSParser.WhileStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 507
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 504
                    self.annotation()
                    self.state = 509
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 510
                self.match(ABSParser.T__30)
                self.state = 511
                self.match(ABSParser.T__2)
                self.state = 512
                localctx.c = self.pure_exp(0)
                self.state = 513
                self.match(ABSParser.T__3)
                self.state = 514
                self.stmt()
                pass

            elif la_ == 9:
                localctx = ABSParser.TryCatchFinallyStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 516
                    self.annotation()
                    self.state = 521
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 522
                self.match(ABSParser.T__31)
                self.state = 523
                localctx.b = self.stmt()
                self.state = 524
                self.match(ABSParser.T__32)
                self.state = 525
                self.match(ABSParser.T__18)
                self.state = 529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==26 or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0):
                    self.state = 526
                    self.casestmtbranch()
                    self.state = 531
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 532
                self.match(ABSParser.T__19)
                self.state = 535
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==34:
                    self.state = 533
                    self.match(ABSParser.T__33)
                    self.state = 534
                    localctx.f = self.stmt()


                pass

            elif la_ == 10:
                localctx = ABSParser.AwaitStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 537
                    self.annotation()
                    self.state = 542
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 543
                self.match(ABSParser.T__7)
                self.state = 544
                self.guard(0)
                self.state = 545
                self.match(ABSParser.T__24)
                pass

            elif la_ == 11:
                localctx = ABSParser.SuspendStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 550
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 547
                    self.annotation()
                    self.state = 552
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 553
                self.match(ABSParser.T__34)
                self.state = 554
                self.match(ABSParser.T__24)
                pass

            elif la_ == 12:
                localctx = ABSParser.DurationStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 555
                    self.annotation()
                    self.state = 560
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 561
                self.match(ABSParser.T__35)
                self.state = 562
                self.match(ABSParser.T__2)
                self.state = 563
                localctx.f = self.pure_exp(0)
                self.state = 564
                self.match(ABSParser.T__1)
                self.state = 565
                localctx.t = self.pure_exp(0)
                self.state = 566
                self.match(ABSParser.T__3)
                self.state = 567
                self.match(ABSParser.T__24)
                pass

            elif la_ == 13:
                localctx = ABSParser.ThrowStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 572
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 569
                    self.annotation()
                    self.state = 574
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 575
                self.match(ABSParser.T__36)
                self.state = 576
                self.pure_exp(0)
                self.state = 577
                self.match(ABSParser.T__24)
                pass

            elif la_ == 14:
                localctx = ABSParser.DieStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 582
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 579
                    self.annotation()
                    self.state = 584
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 585
                self.match(ABSParser.T__37)
                self.state = 586
                self.pure_exp(0)
                self.state = 587
                self.match(ABSParser.T__24)
                pass

            elif la_ == 15:
                localctx = ABSParser.MoveCogToStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 592
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 589
                    self.annotation()
                    self.state = 594
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 595
                self.match(ABSParser.T__38)
                self.state = 596
                self.pure_exp(0)
                self.state = 597
                self.match(ABSParser.T__24)
                pass

            elif la_ == 16:
                localctx = ABSParser.ExpStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 602
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 599
                    self.annotation()
                    self.state = 604
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 605
                self.exp()
                self.state = 606
                self.match(ABSParser.T__24)
                pass

            elif la_ == 17:
                localctx = ABSParser.CaseStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 611
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 608
                    self.annotation()
                    self.state = 613
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 614
                self.match(ABSParser.T__17)
                self.state = 615
                localctx.c = self.pure_exp(0)
                self.state = 616
                self.match(ABSParser.T__18)
                self.state = 620
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==26 or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0):
                    self.state = 617
                    self.casestmtbranch()
                    self.state = 622
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 623
                self.match(ABSParser.T__19)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_guard

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ExpGuardContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.GuardContext
            super().__init__(parser)
            self.e = None # Pure_expContext
            self.copyFrom(ctx)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpGuard" ):
                listener.enterExpGuard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpGuard" ):
                listener.exitExpGuard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpGuard" ):
                return visitor.visitExpGuard(self)
            else:
                return visitor.visitChildren(self)


    class AndGuardContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.GuardContext
            super().__init__(parser)
            self.l = None # GuardContext
            self.r = None # GuardContext
            self.copyFrom(ctx)

        def guard(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.GuardContext)
            else:
                return self.getTypedRuleContext(ABSParser.GuardContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndGuard" ):
                listener.enterAndGuard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndGuard" ):
                listener.exitAndGuard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndGuard" ):
                return visitor.visitAndGuard(self)
            else:
                return visitor.visitChildren(self)


    class ClaimGuardContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.GuardContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def var_or_field_ref(self):
            return self.getTypedRuleContext(ABSParser.Var_or_field_refContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClaimGuard" ):
                listener.enterClaimGuard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClaimGuard" ):
                listener.exitClaimGuard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClaimGuard" ):
                return visitor.visitClaimGuard(self)
            else:
                return visitor.visitChildren(self)


    class DurationGuardContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.GuardContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pure_exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Pure_expContext)
            else:
                return self.getTypedRuleContext(ABSParser.Pure_expContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDurationGuard" ):
                listener.enterDurationGuard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDurationGuard" ):
                listener.exitDurationGuard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDurationGuard" ):
                return visitor.visitDurationGuard(self)
            else:
                return visitor.visitChildren(self)



    def guard(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ABSParser.GuardContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 38
        self.enterRecursionRule(localctx, 38, self.RULE_guard, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                localctx = ABSParser.ClaimGuardContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 628
                self.var_or_field_ref()
                self.state = 629
                self.match(ABSParser.T__39)
                pass

            elif la_ == 2:
                localctx = ABSParser.DurationGuardContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 631
                self.match(ABSParser.T__35)
                self.state = 632
                self.match(ABSParser.T__2)
                self.state = 633
                self.pure_exp(0)
                self.state = 634
                self.match(ABSParser.T__1)
                self.state = 635
                self.pure_exp(0)
                self.state = 636
                self.match(ABSParser.T__3)
                pass

            elif la_ == 3:
                localctx = ABSParser.ExpGuardContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 638
                localctx.e = self.pure_exp(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 646
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,56,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ABSParser.AndGuardContext(self, ABSParser.GuardContext(self, _parentctx, _parentState))
                    localctx.l = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_guard)
                    self.state = 641
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 642
                    self.match(ABSParser.T__40)
                    self.state = 643
                    localctx.r = self.guard(2) 
                self.state = 648
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,56,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CasestmtbranchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self):
            return self.getTypedRuleContext(ABSParser.PatternContext,0)


        def stmt(self):
            return self.getTypedRuleContext(ABSParser.StmtContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_casestmtbranch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCasestmtbranch" ):
                listener.enterCasestmtbranch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCasestmtbranch" ):
                listener.exitCasestmtbranch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCasestmtbranch" ):
                return visitor.visitCasestmtbranch(self)
            else:
                return visitor.visitChildren(self)




    def casestmtbranch(self):

        localctx = ABSParser.CasestmtbranchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_casestmtbranch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.pattern()
            self.state = 650
            self.match(ABSParser.T__23)
            self.state = 651
            self.stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Datatype_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Token
            self._TYPE_IDENTIFIER = None # Token
            self.p = list() # of Tokens
            self._data_constructor = None # Data_constructorContext
            self.c = list() # of Data_constructorContexts

        def TYPE_IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.TYPE_IDENTIFIER)
            else:
                return self.getToken(ABSParser.TYPE_IDENTIFIER, i)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def LT(self):
            return self.getToken(ABSParser.LT, 0)

        def GT(self):
            return self.getToken(ABSParser.GT, 0)

        def data_constructor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Data_constructorContext)
            else:
                return self.getTypedRuleContext(ABSParser.Data_constructorContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_datatype_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype_decl" ):
                listener.enterDatatype_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype_decl" ):
                listener.exitDatatype_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype_decl" ):
                return visitor.visitDatatype_decl(self)
            else:
                return visitor.visitChildren(self)




    def datatype_decl(self):

        localctx = ABSParser.Datatype_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_datatype_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 653
                self.annotation()
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 659
            self.match(ABSParser.T__41)
            self.state = 660
            localctx.n = self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 671
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==101:
                self.state = 661
                self.match(ABSParser.LT)
                self.state = 662
                localctx._TYPE_IDENTIFIER = self.match(ABSParser.TYPE_IDENTIFIER)
                localctx.p.append(localctx._TYPE_IDENTIFIER)
                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 663
                    self.match(ABSParser.T__1)
                    self.state = 664
                    localctx._TYPE_IDENTIFIER = self.match(ABSParser.TYPE_IDENTIFIER)
                    localctx.p.append(localctx._TYPE_IDENTIFIER)
                    self.state = 669
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 670
                self.match(ABSParser.GT)


            self.state = 682
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 673
                self.match(ABSParser.T__21)
                self.state = 674
                localctx._data_constructor = self.data_constructor()
                localctx.c.append(localctx._data_constructor)
                self.state = 679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==43:
                    self.state = 675
                    self.match(ABSParser.T__42)
                    self.state = 676
                    localctx._data_constructor = self.data_constructor()
                    localctx.c.append(localctx._data_constructor)
                    self.state = 681
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 684
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_constructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Token
            self._data_constructor_arg = None # Data_constructor_argContext
            self.a = list() # of Data_constructor_argContexts

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def data_constructor_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Data_constructor_argContext)
            else:
                return self.getTypedRuleContext(ABSParser.Data_constructor_argContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_data_constructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_constructor" ):
                listener.enterData_constructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_constructor" ):
                listener.exitData_constructor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitData_constructor" ):
                return visitor.visitData_constructor(self)
            else:
                return visitor.visitChildren(self)




    def data_constructor(self):

        localctx = ABSParser.Data_constructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_data_constructor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            localctx.n = self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 687
                self.match(ABSParser.T__2)
                self.state = 688
                localctx._data_constructor_arg = self.data_constructor_arg()
                localctx.a.append(localctx._data_constructor_arg)
                self.state = 693
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 689
                    self.match(ABSParser.T__1)
                    self.state = 690
                    localctx._data_constructor_arg = self.data_constructor_arg()
                    localctx.a.append(localctx._data_constructor_arg)
                    self.state = 695
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 696
                self.match(ABSParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_constructor_argContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_data_constructor_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_constructor_arg" ):
                listener.enterData_constructor_arg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_constructor_arg" ):
                listener.exitData_constructor_arg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitData_constructor_arg" ):
                return visitor.visitData_constructor_arg(self)
            else:
                return visitor.visitChildren(self)




    def data_constructor_arg(self):

        localctx = ABSParser.Data_constructor_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_data_constructor_arg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.type_use()
            self.state = 702
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==88:
                self.state = 701
                self.match(ABSParser.IDENTIFIER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Typesyn_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_typesyn_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypesyn_decl" ):
                listener.enterTypesyn_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypesyn_decl" ):
                listener.exitTypesyn_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypesyn_decl" ):
                return visitor.visitTypesyn_decl(self)
            else:
                return visitor.visitChildren(self)




    def typesyn_decl(self):

        localctx = ABSParser.Typesyn_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_typesyn_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 704
                self.annotation()
                self.state = 709
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 710
            self.match(ABSParser.T__43)
            self.state = 711
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 712
            self.match(ABSParser.T__21)
            self.state = 713
            self.type_use()
            self.state = 714
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exception_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Token
            self._data_constructor_arg = None # Data_constructor_argContext
            self.a = list() # of Data_constructor_argContexts

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def data_constructor_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Data_constructor_argContext)
            else:
                return self.getTypedRuleContext(ABSParser.Data_constructor_argContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_exception_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterException_decl" ):
                listener.enterException_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitException_decl" ):
                listener.exitException_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitException_decl" ):
                return visitor.visitException_decl(self)
            else:
                return visitor.visitChildren(self)




    def exception_decl(self):

        localctx = ABSParser.Exception_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_exception_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 716
                self.annotation()
                self.state = 721
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 722
            self.match(ABSParser.T__44)
            self.state = 723
            localctx.n = self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 724
                self.match(ABSParser.T__2)
                self.state = 725
                localctx._data_constructor_arg = self.data_constructor_arg()
                localctx.a.append(localctx._data_constructor_arg)
                self.state = 730
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 726
                    self.match(ABSParser.T__1)
                    self.state = 727
                    localctx._data_constructor_arg = self.data_constructor_arg()
                    localctx.a.append(localctx._data_constructor_arg)
                    self.state = 732
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 733
                self.match(ABSParser.T__3)


            self.state = 737
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # Token
            self._TYPE_IDENTIFIER = None # Token
            self.p = list() # of Tokens
            self.e = None # Pure_expContext

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def paramlist(self):
            return self.getTypedRuleContext(ABSParser.ParamlistContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def LT(self):
            return self.getToken(ABSParser.LT, 0)

        def GT(self):
            return self.getToken(ABSParser.GT, 0)

        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def TYPE_IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.TYPE_IDENTIFIER)
            else:
                return self.getToken(ABSParser.TYPE_IDENTIFIER, i)

        def getRuleIndex(self):
            return ABSParser.RULE_function_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_decl" ):
                listener.enterFunction_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_decl" ):
                listener.exitFunction_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_decl" ):
                return visitor.visitFunction_decl(self)
            else:
                return visitor.visitChildren(self)




    def function_decl(self):

        localctx = ABSParser.Function_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_function_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 742
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 739
                self.annotation()
                self.state = 744
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 745
            self.match(ABSParser.T__45)
            self.state = 746
            self.type_use()
            self.state = 747
            localctx.n = self.match(ABSParser.IDENTIFIER)
            self.state = 758
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==101:
                self.state = 748
                self.match(ABSParser.LT)
                self.state = 749
                localctx._TYPE_IDENTIFIER = self.match(ABSParser.TYPE_IDENTIFIER)
                localctx.p.append(localctx._TYPE_IDENTIFIER)
                self.state = 754
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 750
                    self.match(ABSParser.T__1)
                    self.state = 751
                    localctx._TYPE_IDENTIFIER = self.match(ABSParser.TYPE_IDENTIFIER)
                    localctx.p.append(localctx._TYPE_IDENTIFIER)
                    self.state = 756
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 757
                self.match(ABSParser.GT)


            self.state = 760
            self.paramlist()
            self.state = 761
            self.match(ABSParser.T__21)
            self.state = 764
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [47]:
                self.state = 762
                self.match(ABSParser.T__46)
                pass
            elif token in [3, 13, 14, 15, 18, 21, 88, 89, 90, 91, 92, 93, 94]:
                self.state = 763
                localctx.e = self.pure_exp(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 766
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._interface_name = None # Interface_nameContext
            self.e = list() # of Interface_nameContexts

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def methodsig(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.MethodsigContext)
            else:
                return self.getTypedRuleContext(ABSParser.MethodsigContext,i)


        def interface_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Interface_nameContext)
            else:
                return self.getTypedRuleContext(ABSParser.Interface_nameContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_interface_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_decl" ):
                listener.enterInterface_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_decl" ):
                listener.exitInterface_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_decl" ):
                return visitor.visitInterface_decl(self)
            else:
                return visitor.visitChildren(self)




    def interface_decl(self):

        localctx = ABSParser.Interface_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_interface_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 771
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 768
                self.annotation()
                self.state = 773
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 774
            self.match(ABSParser.T__47)
            self.state = 775
            self.qualified_type_identifier()
            self.state = 785
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 776
                self.match(ABSParser.T__48)
                self.state = 777
                localctx._interface_name = self.interface_name()
                localctx.e.append(localctx._interface_name)
                self.state = 782
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 778
                    self.match(ABSParser.T__1)
                    self.state = 779
                    localctx._interface_name = self.interface_name()
                    localctx.e.append(localctx._interface_name)
                    self.state = 784
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 787
            self.match(ABSParser.T__18)
            self.state = 791
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11 or _la==89:
                self.state = 788
                self.methodsig()
                self.state = 793
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 794
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodsigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def paramlist(self):
            return self.getTypedRuleContext(ABSParser.ParamlistContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_methodsig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodsig" ):
                listener.enterMethodsig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodsig" ):
                listener.exitMethodsig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodsig" ):
                return visitor.visitMethodsig(self)
            else:
                return visitor.visitChildren(self)




    def methodsig(self):

        localctx = ABSParser.MethodsigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_methodsig)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 799
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,77,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 796
                    self.annotation() 
                self.state = 801
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,77,self._ctx)

            self.state = 802
            self.type_use()
            self.state = 803
            self.match(ABSParser.IDENTIFIER)
            self.state = 804
            self.paramlist()
            self.state = 805
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Class_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def paramlist(self):
            return self.getTypedRuleContext(ABSParser.ParamlistContext,0)


        def interface_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Interface_nameContext)
            else:
                return self.getTypedRuleContext(ABSParser.Interface_nameContext,i)


        def field_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Field_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Field_declContext,i)


        def method(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.MethodContext)
            else:
                return self.getTypedRuleContext(ABSParser.MethodContext,i)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_class_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_decl" ):
                listener.enterClass_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_decl" ):
                listener.exitClass_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_decl" ):
                return visitor.visitClass_decl(self)
            else:
                return visitor.visitChildren(self)




    def class_decl(self):

        localctx = ABSParser.Class_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_class_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 810
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 807
                self.annotation()
                self.state = 812
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 813
            self.match(ABSParser.T__49)
            self.state = 814
            self.qualified_type_identifier()
            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 815
                self.paramlist()


            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 818
                self.match(ABSParser.T__50)
                self.state = 819
                self.interface_name()
                self.state = 824
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 820
                    self.match(ABSParser.T__1)
                    self.state = 821
                    self.interface_name()
                    self.state = 826
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 829
            self.match(ABSParser.T__18)
            self.state = 833
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,82,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 830
                    self.field_decl() 
                self.state = 835
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,82,self._ctx)

            self.state = 844
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 836
                self.match(ABSParser.T__18)
                self.state = 840
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1073476333384) != 0) or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 127) != 0):
                    self.state = 837
                    self.stmt()
                    self.state = 842
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 843
                self.match(ABSParser.T__19)


            self.state = 849
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11 or _la==89:
                self.state = 846
                self.method()
                self.state = 851
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 852
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Field_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def pure_exp(self):
            return self.getTypedRuleContext(ABSParser.Pure_expContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_field_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterField_decl" ):
                listener.enterField_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitField_decl" ):
                listener.exitField_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitField_decl" ):
                return visitor.visitField_decl(self)
            else:
                return visitor.visitChildren(self)




    def field_decl(self):

        localctx = ABSParser.Field_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_field_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 857
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 854
                    self.annotation() 
                self.state = 859
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

            self.state = 860
            self.type_use()
            self.state = 861
            self.match(ABSParser.IDENTIFIER)
            self.state = 864
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 862
                self.match(ABSParser.T__21)
                self.state = 863
                self.pure_exp(0)


            self.state = 866
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_use(self):
            return self.getTypedRuleContext(ABSParser.Type_useContext,0)


        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def paramlist(self):
            return self.getTypedRuleContext(ABSParser.ParamlistContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_method

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethod" ):
                listener.enterMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethod" ):
                listener.exitMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethod" ):
                return visitor.visitMethod(self)
            else:
                return visitor.visitChildren(self)




    def method(self):

        localctx = ABSParser.MethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_method)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 871
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 868
                    self.annotation() 
                self.state = 873
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

            self.state = 874
            self.type_use()
            self.state = 875
            self.match(ABSParser.IDENTIFIER)
            self.state = 876
            self.paramlist()
            self.state = 877
            self.match(ABSParser.T__18)
            self.state = 881
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1073476333384) != 0) or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 127) != 0):
                self.state = 878
                self.stmt()
                self.state = 883
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 884
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def module_export(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Module_exportContext)
            else:
                return self.getTypedRuleContext(ABSParser.Module_exportContext,i)


        def module_import(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Module_importContext)
            else:
                return self.getTypedRuleContext(ABSParser.Module_importContext,i)


        def decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.DeclContext)
            else:
                return self.getTypedRuleContext(ABSParser.DeclContext,i)


        def main_block(self):
            return self.getTypedRuleContext(ABSParser.Main_blockContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_module_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_decl" ):
                listener.enterModule_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_decl" ):
                listener.exitModule_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_decl" ):
                return visitor.visitModule_decl(self)
            else:
                return visitor.visitChildren(self)




    def module_decl(self):

        localctx = ABSParser.Module_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_module_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 886
            self.match(ABSParser.T__51)
            self.state = 887
            self.qualified_type_identifier()
            self.state = 888
            self.match(ABSParser.T__24)
            self.state = 892
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==53:
                self.state = 889
                self.module_export()
                self.state = 894
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 898
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==55:
                self.state = 895
                self.module_import()
                self.state = 900
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 904
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 901
                    self.decl() 
                self.state = 906
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

            self.state = 908
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11 or _la==19:
                self.state = 907
                self.main_block()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_exportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._any_identifier = None # Any_identifierContext
            self.s = list() # of Any_identifierContexts
            self.f = None # Qualified_type_identifierContext

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)

        def any_identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Any_identifierContext)
            else:
                return self.getTypedRuleContext(ABSParser.Any_identifierContext,i)


        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_module_export

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_export" ):
                listener.enterModule_export(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_export" ):
                listener.exitModule_export(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_export" ):
                return visitor.visitModule_export(self)
            else:
                return visitor.visitChildren(self)




    def module_export(self):

        localctx = ABSParser.Module_exportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_module_export)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 910
            self.match(ABSParser.T__52)
            self.state = 920
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [95]:
                self.state = 911
                self.match(ABSParser.MULT)
                pass
            elif token in [88, 89]:
                self.state = 912
                localctx._any_identifier = self.any_identifier()
                localctx.s.append(localctx._any_identifier)
                self.state = 917
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 913
                    self.match(ABSParser.T__1)
                    self.state = 914
                    localctx._any_identifier = self.any_identifier()
                    localctx.s.append(localctx._any_identifier)
                    self.state = 919
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

            self.state = 924
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 922
                self.match(ABSParser.T__53)
                self.state = 923
                localctx.f = self.qualified_type_identifier()


            self.state = 926
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_importContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.f = None # Qualified_type_identifierContext
            self._any_identifier = None # Any_identifierContext
            self.s = list() # of Any_identifierContexts

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def any_identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Any_identifierContext)
            else:
                return self.getTypedRuleContext(ABSParser.Any_identifierContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_module_import

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_import" ):
                listener.enterModule_import(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_import" ):
                listener.exitModule_import(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_import" ):
                return visitor.visitModule_import(self)
            else:
                return visitor.visitChildren(self)




    def module_import(self):

        localctx = ABSParser.Module_importContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_module_import)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            self.match(ABSParser.T__54)
            self.state = 956
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 929
                self.match(ABSParser.MULT)
                self.state = 930
                self.match(ABSParser.T__53)
                self.state = 931
                localctx.f = self.qualified_type_identifier()
                self.state = 932
                self.match(ABSParser.T__24)
                pass

            elif la_ == 2:
                self.state = 934
                localctx._any_identifier = self.any_identifier()
                localctx.s.append(localctx._any_identifier)
                self.state = 939
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 935
                    self.match(ABSParser.T__1)
                    self.state = 936
                    localctx._any_identifier = self.any_identifier()
                    localctx.s.append(localctx._any_identifier)
                    self.state = 941
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 942
                self.match(ABSParser.T__53)
                self.state = 943
                localctx.f = self.qualified_type_identifier()
                self.state = 944
                self.match(ABSParser.T__24)
                pass

            elif la_ == 3:
                self.state = 946
                localctx._any_identifier = self.any_identifier()
                localctx.s.append(localctx._any_identifier)
                self.state = 951
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 947
                    self.match(ABSParser.T__1)
                    self.state = 948
                    localctx._any_identifier = self.any_identifier()
                    localctx.s.append(localctx._any_identifier)
                    self.state = 953
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 954
                self.match(ABSParser.T__24)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datatype_decl(self):
            return self.getTypedRuleContext(ABSParser.Datatype_declContext,0)


        def function_decl(self):
            return self.getTypedRuleContext(ABSParser.Function_declContext,0)


        def typesyn_decl(self):
            return self.getTypedRuleContext(ABSParser.Typesyn_declContext,0)


        def exception_decl(self):
            return self.getTypedRuleContext(ABSParser.Exception_declContext,0)


        def interface_decl(self):
            return self.getTypedRuleContext(ABSParser.Interface_declContext,0)


        def class_decl(self):
            return self.getTypedRuleContext(ABSParser.Class_declContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecl" ):
                listener.enterDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecl" ):
                listener.exitDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecl" ):
                return visitor.visitDecl(self)
            else:
                return visitor.visitChildren(self)




    def decl(self):

        localctx = ABSParser.DeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_decl)
        try:
            self.state = 964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 958
                self.datatype_decl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 959
                self.function_decl()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 960
                self.typesyn_decl()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 961
                self.exception_decl()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 962
                self.interface_decl()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 963
                self.class_decl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delta_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._delta_param = None # Delta_paramContext
            self.p = list() # of Delta_paramContexts

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def delta_access(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_accessContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_accessContext,i)


        def module_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Module_modifierContext)
            else:
                return self.getTypedRuleContext(ABSParser.Module_modifierContext,i)


        def delta_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_paramContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_paramContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_delta_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelta_decl" ):
                listener.enterDelta_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelta_decl" ):
                listener.exitDelta_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelta_decl" ):
                return visitor.visitDelta_decl(self)
            else:
                return visitor.visitChildren(self)




    def delta_decl(self):

        localctx = ABSParser.Delta_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_delta_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.match(ABSParser.T__55)
            self.state = 967
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 979
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 968
                self.match(ABSParser.T__2)
                self.state = 969
                localctx._delta_param = self.delta_param()
                localctx.p.append(localctx._delta_param)
                self.state = 974
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 970
                    self.match(ABSParser.T__1)
                    self.state = 971
                    localctx._delta_param = self.delta_param()
                    localctx.p.append(localctx._delta_param)
                    self.state = 976
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 977
                self.match(ABSParser.T__3)


            self.state = 981
            self.match(ABSParser.T__24)
            self.state = 985
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 982
                self.delta_access()
                self.state = 987
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 991
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009213693952) != 0):
                self.state = 988
                self.module_modifier()
                self.state = 993
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delta_paramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_delta_param

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaClassParamContext(Delta_paramContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Delta_paramContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def has_condition(self):
            return self.getTypedRuleContext(ABSParser.Has_conditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaClassParam" ):
                listener.enterDeltaClassParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaClassParam" ):
                listener.exitDeltaClassParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaClassParam" ):
                return visitor.visitDeltaClassParam(self)
            else:
                return visitor.visitChildren(self)


    class DeltaFieldParamContext(Delta_paramContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Delta_paramContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def param_decl(self):
            return self.getTypedRuleContext(ABSParser.Param_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaFieldParam" ):
                listener.enterDeltaFieldParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaFieldParam" ):
                listener.exitDeltaFieldParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaFieldParam" ):
                return visitor.visitDeltaFieldParam(self)
            else:
                return visitor.visitChildren(self)



    def delta_param(self):

        localctx = ABSParser.Delta_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_delta_param)
        try:
            self.state = 998
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                localctx = ABSParser.DeltaFieldParamContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 994
                self.param_decl()
                pass

            elif la_ == 2:
                localctx = ABSParser.DeltaClassParamContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 995
                self.qualified_type_identifier()
                self.state = 996
                self.has_condition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Has_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_has_condition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaHasInterfaceConditionContext(Has_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Has_conditionContext
            super().__init__(parser)
            self.i = None # Interface_nameContext
            self.copyFrom(ctx)

        def interface_name(self):
            return self.getTypedRuleContext(ABSParser.Interface_nameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaHasInterfaceCondition" ):
                listener.enterDeltaHasInterfaceCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaHasInterfaceCondition" ):
                listener.exitDeltaHasInterfaceCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaHasInterfaceCondition" ):
                return visitor.visitDeltaHasInterfaceCondition(self)
            else:
                return visitor.visitChildren(self)


    class DeltaHasMethodConditionContext(Has_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Has_conditionContext
            super().__init__(parser)
            self.m = None # MethodsigContext
            self.copyFrom(ctx)

        def methodsig(self):
            return self.getTypedRuleContext(ABSParser.MethodsigContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaHasMethodCondition" ):
                listener.enterDeltaHasMethodCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaHasMethodCondition" ):
                listener.exitDeltaHasMethodCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaHasMethodCondition" ):
                return visitor.visitDeltaHasMethodCondition(self)
            else:
                return visitor.visitChildren(self)


    class DeltaHasFieldConditionContext(Has_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Has_conditionContext
            super().__init__(parser)
            self.f = None # Field_declContext
            self.copyFrom(ctx)

        def field_decl(self):
            return self.getTypedRuleContext(ABSParser.Field_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaHasFieldCondition" ):
                listener.enterDeltaHasFieldCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaHasFieldCondition" ):
                listener.exitDeltaHasFieldCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaHasFieldCondition" ):
                return visitor.visitDeltaHasFieldCondition(self)
            else:
                return visitor.visitChildren(self)



    def has_condition(self):

        localctx = ABSParser.Has_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_has_condition)
        try:
            self.state = 1006
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57]:
                localctx = ABSParser.DeltaHasFieldConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1000
                self.match(ABSParser.T__56)
                self.state = 1001
                localctx.f = self.field_decl()
                pass
            elif token in [58]:
                localctx = ABSParser.DeltaHasMethodConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1002
                self.match(ABSParser.T__57)
                self.state = 1003
                localctx.m = self.methodsig()
                pass
            elif token in [59]:
                localctx = ABSParser.DeltaHasInterfaceConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1004
                self.match(ABSParser.T__58)
                self.state = 1005
                localctx.i = self.interface_name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delta_accessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_delta_access

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelta_access" ):
                listener.enterDelta_access(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelta_access" ):
                listener.exitDelta_access(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelta_access" ):
                return visitor.visitDelta_access(self)
            else:
                return visitor.visitChildren(self)




    def delta_access(self):

        localctx = ABSParser.Delta_accessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_delta_access)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1008
            self.match(ABSParser.T__59)
            self.state = 1009
            self.qualified_type_identifier()
            self.state = 1010
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_modifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functional_modifier(self):
            return self.getTypedRuleContext(ABSParser.Functional_modifierContext,0)


        def oo_modifier(self):
            return self.getTypedRuleContext(ABSParser.Oo_modifierContext,0)


        def namespace_modifier(self):
            return self.getTypedRuleContext(ABSParser.Namespace_modifierContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_module_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_modifier" ):
                listener.enterModule_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_modifier" ):
                listener.exitModule_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_modifier" ):
                return visitor.visitModule_modifier(self)
            else:
                return visitor.visitChildren(self)




    def module_modifier(self):

        localctx = ABSParser.Module_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_module_modifier)
        try:
            self.state = 1015
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1012
                self.functional_modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1013
                self.oo_modifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1014
                self.namespace_modifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Functional_modifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_functional_modifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaModifyTypeSynModifierContext(Functional_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Functional_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def typesyn_decl(self):
            return self.getTypedRuleContext(ABSParser.Typesyn_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaModifyTypeSynModifier" ):
                listener.enterDeltaModifyTypeSynModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaModifyTypeSynModifier" ):
                listener.exitDeltaModifyTypeSynModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaModifyTypeSynModifier" ):
                return visitor.visitDeltaModifyTypeSynModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddFunctionModifierContext(Functional_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Functional_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def function_decl(self):
            return self.getTypedRuleContext(ABSParser.Function_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddFunctionModifier" ):
                listener.enterDeltaAddFunctionModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddFunctionModifier" ):
                listener.exitDeltaAddFunctionModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddFunctionModifier" ):
                return visitor.visitDeltaAddFunctionModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddDataTypeModifierContext(Functional_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Functional_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datatype_decl(self):
            return self.getTypedRuleContext(ABSParser.Datatype_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddDataTypeModifier" ):
                listener.enterDeltaAddDataTypeModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddDataTypeModifier" ):
                listener.exitDeltaAddDataTypeModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddDataTypeModifier" ):
                return visitor.visitDeltaAddDataTypeModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaModifyDataTypeModifierContext(Functional_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Functional_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datatype_decl(self):
            return self.getTypedRuleContext(ABSParser.Datatype_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaModifyDataTypeModifier" ):
                listener.enterDeltaModifyDataTypeModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaModifyDataTypeModifier" ):
                listener.exitDeltaModifyDataTypeModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaModifyDataTypeModifier" ):
                return visitor.visitDeltaModifyDataTypeModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddTypeSynModifierContext(Functional_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Functional_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def typesyn_decl(self):
            return self.getTypedRuleContext(ABSParser.Typesyn_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddTypeSynModifier" ):
                listener.enterDeltaAddTypeSynModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddTypeSynModifier" ):
                listener.exitDeltaAddTypeSynModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddTypeSynModifier" ):
                return visitor.visitDeltaAddTypeSynModifier(self)
            else:
                return visitor.visitChildren(self)



    def functional_modifier(self):

        localctx = ABSParser.Functional_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_functional_modifier)
        try:
            self.state = 1027
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                localctx = ABSParser.DeltaAddFunctionModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1017
                self.match(ABSParser.T__60)
                self.state = 1018
                self.function_decl()
                pass

            elif la_ == 2:
                localctx = ABSParser.DeltaAddDataTypeModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1019
                self.match(ABSParser.T__60)
                self.state = 1020
                self.datatype_decl()
                pass

            elif la_ == 3:
                localctx = ABSParser.DeltaAddTypeSynModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1021
                self.match(ABSParser.T__60)
                self.state = 1022
                self.typesyn_decl()
                pass

            elif la_ == 4:
                localctx = ABSParser.DeltaModifyTypeSynModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1023
                self.match(ABSParser.T__61)
                self.state = 1024
                self.typesyn_decl()
                pass

            elif la_ == 5:
                localctx = ABSParser.DeltaModifyDataTypeModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1025
                self.match(ABSParser.T__61)
                self.state = 1026
                self.datatype_decl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Oo_modifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_oo_modifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaRemoveInterfaceModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaRemoveInterfaceModifier" ):
                listener.enterDeltaRemoveInterfaceModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaRemoveInterfaceModifier" ):
                listener.exitDeltaRemoveInterfaceModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaRemoveInterfaceModifier" ):
                return visitor.visitDeltaRemoveInterfaceModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaModifyInterfaceModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def interface_modifier_fragment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Interface_modifier_fragmentContext)
            else:
                return self.getTypedRuleContext(ABSParser.Interface_modifier_fragmentContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaModifyInterfaceModifier" ):
                listener.enterDeltaModifyInterfaceModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaModifyInterfaceModifier" ):
                listener.exitDeltaModifyInterfaceModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaModifyInterfaceModifier" ):
                return visitor.visitDeltaModifyInterfaceModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddInterfaceModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def interface_decl(self):
            return self.getTypedRuleContext(ABSParser.Interface_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddInterfaceModifier" ):
                listener.enterDeltaAddInterfaceModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddInterfaceModifier" ):
                listener.exitDeltaAddInterfaceModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddInterfaceModifier" ):
                return visitor.visitDeltaAddInterfaceModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddClassModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def class_decl(self):
            return self.getTypedRuleContext(ABSParser.Class_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddClassModifier" ):
                listener.enterDeltaAddClassModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddClassModifier" ):
                listener.exitDeltaAddClassModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddClassModifier" ):
                return visitor.visitDeltaAddClassModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaRemoveClassModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaRemoveClassModifier" ):
                listener.enterDeltaRemoveClassModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaRemoveClassModifier" ):
                listener.exitDeltaRemoveClassModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaRemoveClassModifier" ):
                return visitor.visitDeltaRemoveClassModifier(self)
            else:
                return visitor.visitChildren(self)


    class DeltaModifyClassModifierContext(Oo_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Oo_modifierContext
            super().__init__(parser)
            self.n = None # Qualified_type_identifierContext
            self._interface_name = None # Interface_nameContext
            self.ia = list() # of Interface_nameContexts
            self.ir = list() # of Interface_nameContexts
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def class_modifier_fragment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Class_modifier_fragmentContext)
            else:
                return self.getTypedRuleContext(ABSParser.Class_modifier_fragmentContext,i)

        def interface_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Interface_nameContext)
            else:
                return self.getTypedRuleContext(ABSParser.Interface_nameContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaModifyClassModifier" ):
                listener.enterDeltaModifyClassModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaModifyClassModifier" ):
                listener.exitDeltaModifyClassModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaModifyClassModifier" ):
                return visitor.visitDeltaModifyClassModifier(self)
            else:
                return visitor.visitChildren(self)



    def oo_modifier(self):

        localctx = ABSParser.Oo_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_oo_modifier)
        self._la = 0 # Token type
        try:
            self.state = 1089
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                localctx = ABSParser.DeltaAddClassModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1029
                self.match(ABSParser.T__60)
                self.state = 1030
                self.class_decl()
                pass

            elif la_ == 2:
                localctx = ABSParser.DeltaRemoveClassModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1031
                self.match(ABSParser.T__62)
                self.state = 1032
                self.match(ABSParser.T__49)
                self.state = 1033
                self.qualified_type_identifier()
                self.state = 1034
                self.match(ABSParser.T__24)
                pass

            elif la_ == 3:
                localctx = ABSParser.DeltaModifyClassModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1036
                self.match(ABSParser.T__61)
                self.state = 1037
                self.match(ABSParser.T__49)
                self.state = 1038
                localctx.n = self.qualified_type_identifier()
                self.state = 1048
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==61:
                    self.state = 1039
                    self.match(ABSParser.T__60)
                    self.state = 1040
                    localctx._interface_name = self.interface_name()
                    localctx.ia.append(localctx._interface_name)
                    self.state = 1045
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 1041
                        self.match(ABSParser.T__1)
                        self.state = 1042
                        localctx._interface_name = self.interface_name()
                        localctx.ia.append(localctx._interface_name)
                        self.state = 1047
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1059
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==63:
                    self.state = 1050
                    self.match(ABSParser.T__62)
                    self.state = 1051
                    localctx._interface_name = self.interface_name()
                    localctx.ir.append(localctx._interface_name)
                    self.state = 1056
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 1052
                        self.match(ABSParser.T__1)
                        self.state = 1053
                        localctx._interface_name = self.interface_name()
                        localctx.ir.append(localctx._interface_name)
                        self.state = 1058
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1061
                self.match(ABSParser.T__18)
                self.state = 1065
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009213693952) != 0):
                    self.state = 1062
                    self.class_modifier_fragment()
                    self.state = 1067
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1068
                self.match(ABSParser.T__19)
                pass

            elif la_ == 4:
                localctx = ABSParser.DeltaAddInterfaceModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1070
                self.match(ABSParser.T__60)
                self.state = 1071
                self.interface_decl()
                pass

            elif la_ == 5:
                localctx = ABSParser.DeltaRemoveInterfaceModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1072
                self.match(ABSParser.T__62)
                self.state = 1073
                self.match(ABSParser.T__47)
                self.state = 1074
                self.qualified_type_identifier()
                self.state = 1075
                self.match(ABSParser.T__24)
                pass

            elif la_ == 6:
                localctx = ABSParser.DeltaModifyInterfaceModifierContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1077
                self.match(ABSParser.T__61)
                self.state = 1078
                self.match(ABSParser.T__47)
                self.state = 1079
                self.qualified_type_identifier()
                self.state = 1080
                self.match(ABSParser.T__18)
                self.state = 1084
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==61 or _la==63:
                    self.state = 1081
                    self.interface_modifier_fragment()
                    self.state = 1086
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1087
                self.match(ABSParser.T__19)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Class_modifier_fragmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_class_modifier_fragment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaRemoveFieldFragmentContext(Class_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Class_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def field_decl(self):
            return self.getTypedRuleContext(ABSParser.Field_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaRemoveFieldFragment" ):
                listener.enterDeltaRemoveFieldFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaRemoveFieldFragment" ):
                listener.exitDeltaRemoveFieldFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaRemoveFieldFragment" ):
                return visitor.visitDeltaRemoveFieldFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaRemoveMethodFragmentContext(Class_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Class_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def methodsig(self):
            return self.getTypedRuleContext(ABSParser.MethodsigContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaRemoveMethodFragment" ):
                listener.enterDeltaRemoveMethodFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaRemoveMethodFragment" ):
                listener.exitDeltaRemoveMethodFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaRemoveMethodFragment" ):
                return visitor.visitDeltaRemoveMethodFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddFieldFragmentContext(Class_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Class_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def field_decl(self):
            return self.getTypedRuleContext(ABSParser.Field_declContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddFieldFragment" ):
                listener.enterDeltaAddFieldFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddFieldFragment" ):
                listener.exitDeltaAddFieldFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddFieldFragment" ):
                return visitor.visitDeltaAddFieldFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaModifyMethodFragmentContext(Class_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Class_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def method(self):
            return self.getTypedRuleContext(ABSParser.MethodContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaModifyMethodFragment" ):
                listener.enterDeltaModifyMethodFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaModifyMethodFragment" ):
                listener.exitDeltaModifyMethodFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaModifyMethodFragment" ):
                return visitor.visitDeltaModifyMethodFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddMethodFragmentContext(Class_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Class_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def method(self):
            return self.getTypedRuleContext(ABSParser.MethodContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddMethodFragment" ):
                listener.enterDeltaAddMethodFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddMethodFragment" ):
                listener.exitDeltaAddMethodFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddMethodFragment" ):
                return visitor.visitDeltaAddMethodFragment(self)
            else:
                return visitor.visitChildren(self)



    def class_modifier_fragment(self):

        localctx = ABSParser.Class_modifier_fragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_class_modifier_fragment)
        try:
            self.state = 1101
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
            if la_ == 1:
                localctx = ABSParser.DeltaAddFieldFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1091
                self.match(ABSParser.T__60)
                self.state = 1092
                self.field_decl()
                pass

            elif la_ == 2:
                localctx = ABSParser.DeltaRemoveFieldFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1093
                self.match(ABSParser.T__62)
                self.state = 1094
                self.field_decl()
                pass

            elif la_ == 3:
                localctx = ABSParser.DeltaAddMethodFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1095
                self.match(ABSParser.T__60)
                self.state = 1096
                self.method()
                pass

            elif la_ == 4:
                localctx = ABSParser.DeltaModifyMethodFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1097
                self.match(ABSParser.T__61)
                self.state = 1098
                self.method()
                pass

            elif la_ == 5:
                localctx = ABSParser.DeltaRemoveMethodFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1099
                self.match(ABSParser.T__62)
                self.state = 1100
                self.methodsig()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interface_modifier_fragmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_interface_modifier_fragment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaRemoveMethodsigFragmentContext(Interface_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Interface_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def methodsig(self):
            return self.getTypedRuleContext(ABSParser.MethodsigContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaRemoveMethodsigFragment" ):
                listener.enterDeltaRemoveMethodsigFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaRemoveMethodsigFragment" ):
                listener.exitDeltaRemoveMethodsigFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaRemoveMethodsigFragment" ):
                return visitor.visitDeltaRemoveMethodsigFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddMethodsigFragmentContext(Interface_modifier_fragmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Interface_modifier_fragmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def methodsig(self):
            return self.getTypedRuleContext(ABSParser.MethodsigContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddMethodsigFragment" ):
                listener.enterDeltaAddMethodsigFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddMethodsigFragment" ):
                listener.exitDeltaAddMethodsigFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddMethodsigFragment" ):
                return visitor.visitDeltaAddMethodsigFragment(self)
            else:
                return visitor.visitChildren(self)



    def interface_modifier_fragment(self):

        localctx = ABSParser.Interface_modifier_fragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_interface_modifier_fragment)
        try:
            self.state = 1107
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61]:
                localctx = ABSParser.DeltaAddMethodsigFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1103
                self.match(ABSParser.T__60)
                self.state = 1104
                self.methodsig()
                pass
            elif token in [63]:
                localctx = ABSParser.DeltaRemoveMethodsigFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1105
                self.match(ABSParser.T__62)
                self.state = 1106
                self.methodsig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Namespace_modifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_namespace_modifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeltaAddModuleExportFragmentContext(Namespace_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Namespace_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def module_export(self):
            return self.getTypedRuleContext(ABSParser.Module_exportContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddModuleExportFragment" ):
                listener.enterDeltaAddModuleExportFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddModuleExportFragment" ):
                listener.exitDeltaAddModuleExportFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddModuleExportFragment" ):
                return visitor.visitDeltaAddModuleExportFragment(self)
            else:
                return visitor.visitChildren(self)


    class DeltaAddModuleImportFragmentContext(Namespace_modifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Namespace_modifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def module_import(self):
            return self.getTypedRuleContext(ABSParser.Module_importContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaAddModuleImportFragment" ):
                listener.enterDeltaAddModuleImportFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaAddModuleImportFragment" ):
                listener.exitDeltaAddModuleImportFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaAddModuleImportFragment" ):
                return visitor.visitDeltaAddModuleImportFragment(self)
            else:
                return visitor.visitChildren(self)



    def namespace_modifier(self):

        localctx = ABSParser.Namespace_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_namespace_modifier)
        try:
            self.state = 1113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                localctx = ABSParser.DeltaAddModuleImportFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1109
                self.match(ABSParser.T__60)
                self.state = 1110
                self.module_import()
                pass

            elif la_ == 2:
                localctx = ABSParser.DeltaAddModuleExportFragmentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1111
                self.match(ABSParser.T__60)
                self.state = 1112
                self.module_export()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_update_decl

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UpdateDeclContext(Update_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Update_declContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)
        def object_update(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Object_updateContext)
            else:
                return self.getTypedRuleContext(ABSParser.Object_updateContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateDecl" ):
                listener.enterUpdateDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateDecl" ):
                listener.exitUpdateDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateDecl" ):
                return visitor.visitUpdateDecl(self)
            else:
                return visitor.visitChildren(self)



    def update_decl(self):

        localctx = ABSParser.Update_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_update_decl)
        self._la = 0 # Token type
        try:
            localctx = ABSParser.UpdateDeclContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1115
            self.match(ABSParser.T__63)
            self.state = 1116
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1117
            self.match(ABSParser.T__24)
            self.state = 1121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==65:
                self.state = 1118
                self.object_update()
                self.state = 1123
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Object_updateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_object_update

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ObjectUpdateDeclContext(Object_updateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Object_updateContext
            super().__init__(parser)
            self._object_update_assign_stmt = None # Object_update_assign_stmtContext
            self.pre = list() # of Object_update_assign_stmtContexts
            self.post = list() # of Object_update_assign_stmtContexts
            self.copyFrom(ctx)

        def qualified_type_identifier(self):
            return self.getTypedRuleContext(ABSParser.Qualified_type_identifierContext,0)

        def guard(self):
            return self.getTypedRuleContext(ABSParser.GuardContext,0)

        def update_preamble_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Update_preamble_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Update_preamble_declContext,i)

        def object_update_assign_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Object_update_assign_stmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.Object_update_assign_stmtContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectUpdateDecl" ):
                listener.enterObjectUpdateDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectUpdateDecl" ):
                listener.exitObjectUpdateDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectUpdateDecl" ):
                return visitor.visitObjectUpdateDecl(self)
            else:
                return visitor.visitChildren(self)



    def object_update(self):

        localctx = ABSParser.Object_updateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_object_update)
        self._la = 0 # Token type
        try:
            localctx = ABSParser.ObjectUpdateDeclContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1124
            self.match(ABSParser.T__64)
            self.state = 1125
            self.qualified_type_identifier()
            self.state = 1126
            self.match(ABSParser.T__18)
            self.state = 1127
            self.match(ABSParser.T__7)
            self.state = 1128
            self.guard(0)
            self.state = 1129
            self.match(ABSParser.T__24)
            self.state = 1133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==89:
                self.state = 1130
                self.update_preamble_decl()
                self.state = 1135
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==13 or _la==88:
                self.state = 1136
                localctx._object_update_assign_stmt = self.object_update_assign_stmt()
                localctx.pre.append(localctx._object_update_assign_stmt)
                self.state = 1141
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1142
            self.match(ABSParser.T__65)
            self.state = 1143
            self.match(ABSParser.T__24)
            self.state = 1147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==13 or _la==88:
                self.state = 1144
                localctx._object_update_assign_stmt = self.object_update_assign_stmt()
                localctx.post.append(localctx._object_update_assign_stmt)
                self.state = 1149
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1150
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Object_update_assign_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_object_update_assign_stmt

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ObjectUpdateAssignStmtContext(Object_update_assign_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Object_update_assign_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def var_or_field_ref(self):
            return self.getTypedRuleContext(ABSParser.Var_or_field_refContext,0)

        def exp(self):
            return self.getTypedRuleContext(ABSParser.ExpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectUpdateAssignStmt" ):
                listener.enterObjectUpdateAssignStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectUpdateAssignStmt" ):
                listener.exitObjectUpdateAssignStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectUpdateAssignStmt" ):
                return visitor.visitObjectUpdateAssignStmt(self)
            else:
                return visitor.visitChildren(self)



    def object_update_assign_stmt(self):

        localctx = ABSParser.Object_update_assign_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_object_update_assign_stmt)
        try:
            localctx = ABSParser.ObjectUpdateAssignStmtContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1152
            self.var_or_field_ref()
            self.state = 1153
            self.match(ABSParser.T__21)
            self.state = 1154
            self.exp()
            self.state = 1155
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_preamble_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_update_preamble_decl

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UpdatePreambleDeclContext(Update_preamble_declContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Update_preamble_declContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_exp(self):
            return self.getTypedRuleContext(ABSParser.Type_expContext,0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdatePreambleDecl" ):
                listener.enterUpdatePreambleDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdatePreambleDecl" ):
                listener.exitUpdatePreambleDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdatePreambleDecl" ):
                return visitor.visitUpdatePreambleDecl(self)
            else:
                return visitor.visitChildren(self)



    def update_preamble_decl(self):

        localctx = ABSParser.Update_preamble_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_update_preamble_decl)
        try:
            localctx = ABSParser.UpdatePreambleDeclContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.type_exp()
            self.state = 1158
            self.match(ABSParser.IDENTIFIER)
            self.state = 1159
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Productline_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def feature(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.FeatureContext)
            else:
                return self.getTypedRuleContext(ABSParser.FeatureContext,i)


        def delta_clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_clauseContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_clauseContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_productline_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProductline_decl" ):
                listener.enterProductline_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProductline_decl" ):
                listener.exitProductline_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProductline_decl" ):
                return visitor.visitProductline_decl(self)
            else:
                return visitor.visitChildren(self)




    def productline_decl(self):

        localctx = ABSParser.Productline_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_productline_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1161
            self.match(ABSParser.T__66)
            self.state = 1162
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1163
            self.match(ABSParser.T__24)
            self.state = 1164
            self.match(ABSParser.T__67)
            self.state = 1165
            self.feature()
            self.state = 1170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1166
                self.match(ABSParser.T__1)
                self.state = 1167
                self.feature()
                self.state = 1172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1173
            self.match(ABSParser.T__24)
            self.state = 1177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 1174
                self.delta_clause()
                self.state = 1179
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.p = None # Token

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def attr_assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Attr_assignmentContext)
            else:
                return self.getTypedRuleContext(ABSParser.Attr_assignmentContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_feature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeature" ):
                listener.enterFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeature" ):
                listener.exitFeature(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeature" ):
                return visitor.visitFeature(self)
            else:
                return visitor.visitChildren(self)




    def feature(self):

        localctx = ABSParser.FeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_feature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1180
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
            if la_ == 1:
                self.state = 1181
                localctx.p = self.match(ABSParser.T__68)


            self.state = 1195
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.state = 1184
                self.match(ABSParser.T__18)
                self.state = 1185
                self.attr_assignment()
                self.state = 1190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 1186
                    self.match(ABSParser.T__1)
                    self.state = 1187
                    self.attr_assignment()
                    self.state = 1192
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1193
                self.match(ABSParser.T__19)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delta_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deltaspec(self):
            return self.getTypedRuleContext(ABSParser.DeltaspecContext,0)


        def after_condition(self):
            return self.getTypedRuleContext(ABSParser.After_conditionContext,0)


        def from_condition(self):
            return self.getTypedRuleContext(ABSParser.From_conditionContext,0)


        def when_condition(self):
            return self.getTypedRuleContext(ABSParser.When_conditionContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_delta_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelta_clause" ):
                listener.enterDelta_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelta_clause" ):
                listener.exitDelta_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelta_clause" ):
                return visitor.visitDelta_clause(self)
            else:
                return visitor.visitChildren(self)




    def delta_clause(self):

        localctx = ABSParser.Delta_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_delta_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1197
            self.match(ABSParser.T__55)
            self.state = 1198
            self.deltaspec()
            self.state = 1200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 1199
                self.after_condition()


            self.state = 1203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 1202
                self.from_condition()


            self.state = 1206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71 or _la==72:
                self.state = 1205
                self.when_condition()


            self.state = 1208
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeltaspecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def deltaspec_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Deltaspec_paramContext)
            else:
                return self.getTypedRuleContext(ABSParser.Deltaspec_paramContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_deltaspec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeltaspec" ):
                listener.enterDeltaspec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeltaspec" ):
                listener.exitDeltaspec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeltaspec" ):
                return visitor.visitDeltaspec(self)
            else:
                return visitor.visitChildren(self)




    def deltaspec(self):

        localctx = ABSParser.DeltaspecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_deltaspec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1210
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1222
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 1211
                self.match(ABSParser.T__2)
                self.state = 1212
                self.deltaspec_param()
                self.state = 1217
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 1213
                    self.match(ABSParser.T__1)
                    self.state = 1214
                    self.deltaspec_param()
                    self.state = 1219
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1220
                self.match(ABSParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Deltaspec_paramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_deltaspec_param

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FIDAIDDeltaspecParamContext(Deltaspec_paramContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Deltaspec_paramContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)
        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFIDAIDDeltaspecParam" ):
                listener.enterFIDAIDDeltaspecParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFIDAIDDeltaspecParam" ):
                listener.exitFIDAIDDeltaspecParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFIDAIDDeltaspecParam" ):
                return visitor.visitFIDAIDDeltaspecParam(self)
            else:
                return visitor.visitChildren(self)


    class BoolOrIDDeltaspecParamContext(Deltaspec_paramContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Deltaspec_paramContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolOrIDDeltaspecParam" ):
                listener.enterBoolOrIDDeltaspecParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolOrIDDeltaspecParam" ):
                listener.exitBoolOrIDDeltaspecParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolOrIDDeltaspecParam" ):
                return visitor.visitBoolOrIDDeltaspecParam(self)
            else:
                return visitor.visitChildren(self)


    class IntDeltaspecParamContext(Deltaspec_paramContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Deltaspec_paramContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntDeltaspecParam" ):
                listener.enterIntDeltaspecParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntDeltaspecParam" ):
                listener.exitIntDeltaspecParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntDeltaspecParam" ):
                return visitor.visitIntDeltaspecParam(self)
            else:
                return visitor.visitChildren(self)



    def deltaspec_param(self):

        localctx = ABSParser.Deltaspec_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_deltaspec_param)
        try:
            self.state = 1229
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
            if la_ == 1:
                localctx = ABSParser.FIDAIDDeltaspecParamContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1224
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1225
                self.match(ABSParser.T__0)
                self.state = 1226
                self.match(ABSParser.IDENTIFIER)
                pass

            elif la_ == 2:
                localctx = ABSParser.IntDeltaspecParamContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1227
                self.match(ABSParser.INTLITERAL)
                pass

            elif la_ == 3:
                localctx = ABSParser.BoolOrIDDeltaspecParamContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1228
                self.match(ABSParser.TYPE_IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class After_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def delta_id(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_idContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_idContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_after_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfter_condition" ):
                listener.enterAfter_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfter_condition" ):
                listener.exitAfter_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfter_condition" ):
                return visitor.visitAfter_condition(self)
            else:
                return visitor.visitChildren(self)




    def after_condition(self):

        localctx = ABSParser.After_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_after_condition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1231
            self.match(ABSParser.T__69)
            self.state = 1232
            self.delta_id()
            self.state = 1237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1233
                self.match(ABSParser.T__1)
                self.state = 1234
                self.delta_id()
                self.state = 1239
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def application_condition(self):
            return self.getTypedRuleContext(ABSParser.Application_conditionContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_from_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_condition" ):
                listener.enterFrom_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_condition" ):
                listener.exitFrom_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrom_condition" ):
                return visitor.visitFrom_condition(self)
            else:
                return visitor.visitChildren(self)




    def from_condition(self):

        localctx = ABSParser.From_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_from_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1240
            self.match(ABSParser.T__53)
            self.state = 1241
            self.application_condition(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class When_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def application_condition(self):
            return self.getTypedRuleContext(ABSParser.Application_conditionContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_when_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhen_condition" ):
                listener.enterWhen_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhen_condition" ):
                listener.exitWhen_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhen_condition" ):
                return visitor.visitWhen_condition(self)
            else:
                return visitor.visitChildren(self)




    def when_condition(self):

        localctx = ABSParser.When_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_when_condition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1243
            _la = self._input.LA(1)
            if not(_la==71 or _la==72):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1244
            self.application_condition(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Application_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_application_condition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class FeatureApplicationConditionContext(Application_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Application_conditionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def feature(self):
            return self.getTypedRuleContext(ABSParser.FeatureContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeatureApplicationCondition" ):
                listener.enterFeatureApplicationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeatureApplicationCondition" ):
                listener.exitFeatureApplicationCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeatureApplicationCondition" ):
                return visitor.visitFeatureApplicationCondition(self)
            else:
                return visitor.visitChildren(self)


    class AndApplicationConditionContext(Application_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Application_conditionContext
            super().__init__(parser)
            self.l = None # Application_conditionContext
            self.r = None # Application_conditionContext
            self.copyFrom(ctx)

        def ANDAND(self):
            return self.getToken(ABSParser.ANDAND, 0)
        def application_condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Application_conditionContext)
            else:
                return self.getTypedRuleContext(ABSParser.Application_conditionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndApplicationCondition" ):
                listener.enterAndApplicationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndApplicationCondition" ):
                listener.exitAndApplicationCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndApplicationCondition" ):
                return visitor.visitAndApplicationCondition(self)
            else:
                return visitor.visitChildren(self)


    class ParenApplicationConditionContext(Application_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Application_conditionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def application_condition(self):
            return self.getTypedRuleContext(ABSParser.Application_conditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenApplicationCondition" ):
                listener.enterParenApplicationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenApplicationCondition" ):
                listener.exitParenApplicationCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenApplicationCondition" ):
                return visitor.visitParenApplicationCondition(self)
            else:
                return visitor.visitChildren(self)


    class NotApplicationConditionContext(Application_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Application_conditionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def application_condition(self):
            return self.getTypedRuleContext(ABSParser.Application_conditionContext,0)

        def NEGATION(self):
            return self.getToken(ABSParser.NEGATION, 0)
        def NEGATION_CREOL(self):
            return self.getToken(ABSParser.NEGATION_CREOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotApplicationCondition" ):
                listener.enterNotApplicationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotApplicationCondition" ):
                listener.exitNotApplicationCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotApplicationCondition" ):
                return visitor.visitNotApplicationCondition(self)
            else:
                return visitor.visitChildren(self)


    class OrApplicationConditionContext(Application_conditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Application_conditionContext
            super().__init__(parser)
            self.l = None # Application_conditionContext
            self.r = None # Application_conditionContext
            self.copyFrom(ctx)

        def OROR(self):
            return self.getToken(ABSParser.OROR, 0)
        def application_condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Application_conditionContext)
            else:
                return self.getTypedRuleContext(ABSParser.Application_conditionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrApplicationCondition" ):
                listener.enterOrApplicationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrApplicationCondition" ):
                listener.exitOrApplicationCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrApplicationCondition" ):
                return visitor.visitOrApplicationCondition(self)
            else:
                return visitor.visitChildren(self)



    def application_condition(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ABSParser.Application_conditionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 116
        self.enterRecursionRule(localctx, 116, self.RULE_application_condition, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [92, 93]:
                localctx = ABSParser.NotApplicationConditionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1247
                _la = self._input.LA(1)
                if not(_la==92 or _la==93):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1248
                self.application_condition(5)
                pass
            elif token in [3]:
                localctx = ABSParser.ParenApplicationConditionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1249
                self.match(ABSParser.T__2)
                self.state = 1250
                self.application_condition(0)
                self.state = 1251
                self.match(ABSParser.T__3)
                pass
            elif token in [89]:
                localctx = ABSParser.FeatureApplicationConditionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1253
                self.feature()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 1264
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,137,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1262
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
                    if la_ == 1:
                        localctx = ABSParser.AndApplicationConditionContext(self, ABSParser.Application_conditionContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_application_condition)
                        self.state = 1256
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 1257
                        self.match(ABSParser.ANDAND)
                        self.state = 1258
                        localctx.r = self.application_condition(5)
                        pass

                    elif la_ == 2:
                        localctx = ABSParser.OrApplicationConditionContext(self, ABSParser.Application_conditionContext(self, _parentctx, _parentState))
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_application_condition)
                        self.state = 1259
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1260
                        self.match(ABSParser.OROR)
                        self.state = 1261
                        localctx.r = self.application_condition(4)
                        pass

             
                self.state = 1266
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,137,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Attr_assignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.i = None # Token
            self.b = None # Token
            self.s = None # Token

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def STRINGLITERAL(self):
            return self.getToken(ABSParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_attr_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttr_assignment" ):
                listener.enterAttr_assignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttr_assignment" ):
                listener.exitAttr_assignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttr_assignment" ):
                return visitor.visitAttr_assignment(self)
            else:
                return visitor.visitChildren(self)




    def attr_assignment(self):

        localctx = ABSParser.Attr_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_attr_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1267
            self.match(ABSParser.IDENTIFIER)
            self.state = 1268
            self.match(ABSParser.T__21)
            self.state = 1272
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [90]:
                self.state = 1269
                localctx.i = self.match(ABSParser.INTLITERAL)
                pass
            elif token in [89]:
                self.state = 1270
                localctx.b = self.match(ABSParser.TYPE_IDENTIFIER)
                pass
            elif token in [91]:
                self.state = 1271
                localctx.s = self.match(ABSParser.STRINGLITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Product_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def feature(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.FeatureContext)
            else:
                return self.getTypedRuleContext(ABSParser.FeatureContext,i)


        def product_reconfiguration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Product_reconfigurationContext)
            else:
                return self.getTypedRuleContext(ABSParser.Product_reconfigurationContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_product_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProduct_decl" ):
                listener.enterProduct_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProduct_decl" ):
                listener.exitProduct_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProduct_decl" ):
                return visitor.visitProduct_decl(self)
            else:
                return visitor.visitChildren(self)




    def product_decl(self):

        localctx = ABSParser.Product_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_product_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1274
            self.match(ABSParser.T__72)
            self.state = 1275
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1276
            self.match(ABSParser.T__2)
            self.state = 1285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==89:
                self.state = 1277
                self.feature()
                self.state = 1282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 1278
                    self.match(ABSParser.T__1)
                    self.state = 1279
                    self.feature()
                    self.state = 1284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1287
            self.match(ABSParser.T__3)
            self.state = 1297
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.state = 1288
                self.match(ABSParser.T__18)
                self.state = 1292
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==89:
                    self.state = 1289
                    self.product_reconfiguration()
                    self.state = 1294
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1295
                self.match(ABSParser.T__19)
                pass
            elif token in [25]:
                self.state = 1296
                self.match(ABSParser.T__24)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Product_reconfigurationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.product = None # Token
            self.update = None # Token

        def delta_id(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_idContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_idContext,i)


        def TYPE_IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.TYPE_IDENTIFIER)
            else:
                return self.getToken(ABSParser.TYPE_IDENTIFIER, i)

        def getRuleIndex(self):
            return ABSParser.RULE_product_reconfiguration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProduct_reconfiguration" ):
                listener.enterProduct_reconfiguration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProduct_reconfiguration" ):
                listener.exitProduct_reconfiguration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProduct_reconfiguration" ):
                return visitor.visitProduct_reconfiguration(self)
            else:
                return visitor.visitChildren(self)




    def product_reconfiguration(self):

        localctx = ABSParser.Product_reconfigurationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_product_reconfiguration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            localctx.product = self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1300
            self.match(ABSParser.T__55)
            self.state = 1301
            self.delta_id()
            self.state = 1306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1302
                self.match(ABSParser.T__1)
                self.state = 1303
                self.delta_id()
                self.state = 1308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1309
            self.match(ABSParser.T__63)
            self.state = 1310
            localctx.update = self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1311
            self.match(ABSParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FextensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def feature_decl_group(self):
            return self.getTypedRuleContext(ABSParser.Feature_decl_groupContext,0)


        def feature_decl_attribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Feature_decl_attributeContext)
            else:
                return self.getTypedRuleContext(ABSParser.Feature_decl_attributeContext,i)


        def feature_decl_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Feature_decl_constraintContext)
            else:
                return self.getTypedRuleContext(ABSParser.Feature_decl_constraintContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_fextension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFextension" ):
                listener.enterFextension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFextension" ):
                listener.exitFextension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFextension" ):
                return visitor.visitFextension(self)
            else:
                return visitor.visitChildren(self)




    def fextension(self):

        localctx = ABSParser.FextensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_fextension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1314
            self.match(ABSParser.T__18)
            self.state = 1316
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 1315
                self.feature_decl_group()


            self.state = 1322
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==3 or ((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 52751) != 0):
                self.state = 1320
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
                if la_ == 1:
                    self.state = 1318
                    self.feature_decl_attribute()
                    pass

                elif la_ == 2:
                    self.state = 1319
                    self.feature_decl_constraint()
                    pass


                self.state = 1324
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1325
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Feature_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def feature_decl_group(self):
            return self.getTypedRuleContext(ABSParser.Feature_decl_groupContext,0)


        def feature_decl_attribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Feature_decl_attributeContext)
            else:
                return self.getTypedRuleContext(ABSParser.Feature_decl_attributeContext,i)


        def feature_decl_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Feature_decl_constraintContext)
            else:
                return self.getTypedRuleContext(ABSParser.Feature_decl_constraintContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_feature_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeature_decl" ):
                listener.enterFeature_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeature_decl" ):
                listener.exitFeature_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeature_decl" ):
                return visitor.visitFeature_decl(self)
            else:
                return visitor.visitChildren(self)




    def feature_decl(self):

        localctx = ABSParser.Feature_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_feature_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1327
            self.match(ABSParser.TYPE_IDENTIFIER)
            self.state = 1340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 1328
                self.match(ABSParser.T__18)
                self.state = 1330
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 1329
                    self.feature_decl_group()


                self.state = 1336
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==3 or ((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 52751) != 0):
                    self.state = 1334
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                    if la_ == 1:
                        self.state = 1332
                        self.feature_decl_attribute()
                        pass

                    elif la_ == 2:
                        self.state = 1333
                        self.feature_decl_constraint()
                        pass


                    self.state = 1338
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1339
                self.match(ABSParser.T__19)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Feature_decl_groupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.o = None # Token
            self.a = None # Token
            self.l = None # Token
            self.u = None # Token
            self.s = None # Token

        def fnode(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.FnodeContext)
            else:
                return self.getTypedRuleContext(ABSParser.FnodeContext,i)


        def INTLITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(ABSParser.INTLITERAL)
            else:
                return self.getToken(ABSParser.INTLITERAL, i)

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_feature_decl_group

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeature_decl_group" ):
                listener.enterFeature_decl_group(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeature_decl_group" ):
                listener.exitFeature_decl_group(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeature_decl_group" ):
                return visitor.visitFeature_decl_group(self)
            else:
                return visitor.visitChildren(self)




    def feature_decl_group(self):

        localctx = ABSParser.Feature_decl_groupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_feature_decl_group)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1342
            self.match(ABSParser.T__73)
            self.state = 1353
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [75]:
                self.state = 1343
                localctx.o = self.match(ABSParser.T__74)
                pass
            elif token in [76]:
                self.state = 1344
                localctx.a = self.match(ABSParser.T__75)
                pass
            elif token in [11]:
                self.state = 1345
                self.match(ABSParser.T__10)
                self.state = 1346
                localctx.l = self.match(ABSParser.INTLITERAL)
                self.state = 1347
                self.match(ABSParser.T__76)
                self.state = 1350
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [90]:
                    self.state = 1348
                    localctx.u = self.match(ABSParser.INTLITERAL)
                    pass
                elif token in [95]:
                    self.state = 1349
                    localctx.s = self.match(ABSParser.MULT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1352
                self.match(ABSParser.T__11)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1355
            self.match(ABSParser.T__18)
            self.state = 1356
            self.fnode()
            self.state = 1361
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1357
                self.match(ABSParser.T__1)
                self.state = 1358
                self.fnode()
                self.state = 1363
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1364
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FnodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.o = None # Token

        def feature_decl(self):
            return self.getTypedRuleContext(ABSParser.Feature_declContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_fnode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFnode" ):
                listener.enterFnode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFnode" ):
                listener.exitFnode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFnode" ):
                return visitor.visitFnode(self)
            else:
                return visitor.visitChildren(self)




    def fnode(self):

        localctx = ABSParser.FnodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_fnode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==78:
                self.state = 1366
                localctx.o = self.match(ABSParser.T__77)


            self.state = 1369
            self.feature_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Feature_decl_attributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.l = None # Boundary_intContext
            self.u = None # Boundary_intContext

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def boundary_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Boundary_valContext)
            else:
                return self.getTypedRuleContext(ABSParser.Boundary_valContext,i)


        def boundary_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Boundary_intContext)
            else:
                return self.getTypedRuleContext(ABSParser.Boundary_intContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_feature_decl_attribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeature_decl_attribute" ):
                listener.enterFeature_decl_attribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeature_decl_attribute" ):
                listener.exitFeature_decl_attribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeature_decl_attribute" ):
                return visitor.visitFeature_decl_attribute(self)
            else:
                return visitor.visitChildren(self)




    def feature_decl_attribute(self):

        localctx = ABSParser.Feature_decl_attributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_feature_decl_attribute)
        self._la = 0 # Token type
        try:
            self.state = 1408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1371
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1372
                self.match(ABSParser.IDENTIFIER)
                self.state = 1373
                self.match(ABSParser.T__22)
                self.state = 1374
                self.match(ABSParser.T__18)
                self.state = 1375
                self.boundary_val()
                self.state = 1380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 1376
                    self.match(ABSParser.T__1)
                    self.state = 1377
                    self.boundary_val()
                    self.state = 1382
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1383
                self.match(ABSParser.T__19)
                self.state = 1384
                self.match(ABSParser.T__24)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1386
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1387
                self.match(ABSParser.IDENTIFIER)
                self.state = 1388
                self.match(ABSParser.T__22)
                self.state = 1389
                self.match(ABSParser.T__10)
                self.state = 1390
                localctx.l = self.boundary_int()
                self.state = 1391
                self.match(ABSParser.T__76)
                self.state = 1392
                localctx.u = self.boundary_int()
                self.state = 1393
                self.match(ABSParser.T__11)
                self.state = 1394
                self.match(ABSParser.T__24)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1396
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1397
                self.match(ABSParser.T__10)
                self.state = 1398
                localctx.l = self.boundary_int()
                self.state = 1399
                self.match(ABSParser.T__76)
                self.state = 1400
                localctx.u = self.boundary_int()
                self.state = 1401
                self.match(ABSParser.T__11)
                self.state = 1402
                self.match(ABSParser.IDENTIFIER)
                self.state = 1403
                self.match(ABSParser.T__24)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1405
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1406
                self.match(ABSParser.IDENTIFIER)
                self.state = 1407
                self.match(ABSParser.T__24)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Feature_decl_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ABSParser.RULE_feature_decl_constraint

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FeatureDeclConstraintIfInContext(Feature_decl_constraintContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Feature_decl_constraintContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def mexp(self):
            return self.getTypedRuleContext(ABSParser.MexpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeatureDeclConstraintIfIn" ):
                listener.enterFeatureDeclConstraintIfIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeatureDeclConstraintIfIn" ):
                listener.exitFeatureDeclConstraintIfIn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeatureDeclConstraintIfIn" ):
                return visitor.visitFeatureDeclConstraintIfIn(self)
            else:
                return visitor.visitChildren(self)


    class FeatureDeclConstraintRequireContext(Feature_decl_constraintContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Feature_decl_constraintContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeatureDeclConstraintRequire" ):
                listener.enterFeatureDeclConstraintRequire(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeatureDeclConstraintRequire" ):
                listener.exitFeatureDeclConstraintRequire(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeatureDeclConstraintRequire" ):
                return visitor.visitFeatureDeclConstraintRequire(self)
            else:
                return visitor.visitChildren(self)


    class FeatureDeclConstraintIfOutContext(Feature_decl_constraintContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Feature_decl_constraintContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def mexp(self):
            return self.getTypedRuleContext(ABSParser.MexpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeatureDeclConstraintIfOut" ):
                listener.enterFeatureDeclConstraintIfOut(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeatureDeclConstraintIfOut" ):
                listener.exitFeatureDeclConstraintIfOut(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeatureDeclConstraintIfOut" ):
                return visitor.visitFeatureDeclConstraintIfOut(self)
            else:
                return visitor.visitChildren(self)


    class FeatureDeclConstraintExcludeContext(Feature_decl_constraintContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ABSParser.Feature_decl_constraintContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeatureDeclConstraintExclude" ):
                listener.enterFeatureDeclConstraintExclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeatureDeclConstraintExclude" ):
                listener.exitFeatureDeclConstraintExclude(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeatureDeclConstraintExclude" ):
                return visitor.visitFeatureDeclConstraintExclude(self)
            else:
                return visitor.visitChildren(self)



    def feature_decl_constraint(self):

        localctx = ABSParser.Feature_decl_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_feature_decl_constraint)
        self._la = 0 # Token type
        try:
            self.state = 1430
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 79, 88, 89, 90, 93, 94]:
                localctx = ABSParser.FeatureDeclConstraintIfInContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1412
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==79:
                    self.state = 1410
                    self.match(ABSParser.T__78)
                    self.state = 1411
                    self.match(ABSParser.T__26)


                self.state = 1414
                self.mexp(0)
                self.state = 1415
                self.match(ABSParser.T__24)
                pass
            elif token in [80]:
                localctx = ABSParser.FeatureDeclConstraintIfOutContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1417
                self.match(ABSParser.T__79)
                self.state = 1418
                self.match(ABSParser.T__26)
                self.state = 1419
                self.mexp(0)
                self.state = 1420
                self.match(ABSParser.T__24)
                pass
            elif token in [81]:
                localctx = ABSParser.FeatureDeclConstraintExcludeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1422
                self.match(ABSParser.T__80)
                self.state = 1423
                self.match(ABSParser.T__26)
                self.state = 1424
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1425
                self.match(ABSParser.T__24)
                pass
            elif token in [82]:
                localctx = ABSParser.FeatureDeclConstraintRequireContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1426
                self.match(ABSParser.T__81)
                self.state = 1427
                self.match(ABSParser.T__26)
                self.state = 1428
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1429
                self.match(ABSParser.T__24)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.l = None # MexpContext
            self.op = None # Token
            self.a = None # MexpContext
            self.r = None # MexpContext

        def TYPE_IDENTIFIER(self):
            return self.getToken(ABSParser.TYPE_IDENTIFIER, 0)

        def IDENTIFIER(self):
            return self.getToken(ABSParser.IDENTIFIER, 0)

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def mexp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.MexpContext)
            else:
                return self.getTypedRuleContext(ABSParser.MexpContext,i)


        def NEGATION(self):
            return self.getToken(ABSParser.NEGATION, 0)

        def MINUS(self):
            return self.getToken(ABSParser.MINUS, 0)

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)

        def DIV(self):
            return self.getToken(ABSParser.DIV, 0)

        def MOD(self):
            return self.getToken(ABSParser.MOD, 0)

        def PLUS(self):
            return self.getToken(ABSParser.PLUS, 0)

        def LT(self):
            return self.getToken(ABSParser.LT, 0)

        def GT(self):
            return self.getToken(ABSParser.GT, 0)

        def LTEQ(self):
            return self.getToken(ABSParser.LTEQ, 0)

        def GTEQ(self):
            return self.getToken(ABSParser.GTEQ, 0)

        def EQEQ(self):
            return self.getToken(ABSParser.EQEQ, 0)

        def NOTEQ(self):
            return self.getToken(ABSParser.NOTEQ, 0)

        def IMPLIES(self):
            return self.getToken(ABSParser.IMPLIES, 0)

        def EQUIV(self):
            return self.getToken(ABSParser.EQUIV, 0)

        def ANDAND(self):
            return self.getToken(ABSParser.ANDAND, 0)

        def OROR(self):
            return self.getToken(ABSParser.OROR, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_mexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMexp" ):
                listener.enterMexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMexp" ):
                listener.exitMexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMexp" ):
                return visitor.visitMexp(self)
            else:
                return visitor.visitChildren(self)



    def mexp(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ABSParser.MexpContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 136
        self.enterRecursionRule(localctx, 136, self.RULE_mexp, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1445
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,159,self._ctx)
            if la_ == 1:
                self.state = 1433
                self.match(ABSParser.TYPE_IDENTIFIER)
                self.state = 1434
                self.match(ABSParser.T__0)
                self.state = 1435
                self.match(ABSParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.state = 1436
                self.match(ABSParser.TYPE_IDENTIFIER)
                pass

            elif la_ == 3:
                self.state = 1437
                self.match(ABSParser.INTLITERAL)
                pass

            elif la_ == 4:
                self.state = 1438
                self.match(ABSParser.IDENTIFIER)
                pass

            elif la_ == 5:
                self.state = 1439
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==93 or _la==94):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1440
                localctx.a = self.mexp(9)
                pass

            elif la_ == 6:
                self.state = 1441
                self.match(ABSParser.T__2)
                self.state = 1442
                localctx.a = self.mexp(0)
                self.state = 1443
                self.match(ABSParser.T__3)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1470
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1468
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                    if la_ == 1:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1447
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 1448
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 7) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1449
                        localctx.r = self.mexp(9)
                        pass

                    elif la_ == 2:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1450
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 1451
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==94 or _la==98):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1452
                        localctx.r = self.mexp(8)
                        pass

                    elif la_ == 3:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1453
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 1454
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 99)) & ~0x3f) == 0 and ((1 << (_la - 99)) & 15) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1455
                        localctx.r = self.mexp(7)
                        pass

                    elif la_ == 4:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1456
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 1457
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==105 or _la==106):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1458
                        localctx.r = self.mexp(6)
                        pass

                    elif la_ == 5:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1459
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 1460
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==107 or _la==108):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1461
                        localctx.r = self.mexp(5)
                        pass

                    elif la_ == 6:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1462
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1463
                        localctx.op = self.match(ABSParser.ANDAND)
                        self.state = 1464
                        localctx.r = self.mexp(4)
                        pass

                    elif la_ == 7:
                        localctx = ABSParser.MexpContext(self, _parentctx, _parentState)
                        localctx.l = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mexp)
                        self.state = 1465
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 1466
                        localctx.op = self.match(ABSParser.OROR)
                        self.state = 1467
                        localctx.r = self.mexp(3)
                        pass

             
                self.state = 1472
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Boundary_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.star = None # Token

        def MULT(self):
            return self.getToken(ABSParser.MULT, 0)

        def boundary_val(self):
            return self.getTypedRuleContext(ABSParser.Boundary_valContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_boundary_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoundary_int" ):
                listener.enterBoundary_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoundary_int" ):
                listener.exitBoundary_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoundary_int" ):
                return visitor.visitBoundary_int(self)
            else:
                return visitor.visitChildren(self)




    def boundary_int(self):

        localctx = ABSParser.Boundary_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_boundary_int)
        try:
            self.state = 1475
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [95]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1473
                localctx.star = self.match(ABSParser.MULT)
                pass
            elif token in [90, 94]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1474
                self.boundary_val()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boundary_valContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.m = None # Token
            self.i = None # Token

        def INTLITERAL(self):
            return self.getToken(ABSParser.INTLITERAL, 0)

        def MINUS(self):
            return self.getToken(ABSParser.MINUS, 0)

        def getRuleIndex(self):
            return ABSParser.RULE_boundary_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoundary_val" ):
                listener.enterBoundary_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoundary_val" ):
                listener.exitBoundary_val(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoundary_val" ):
                return visitor.visitBoundary_val(self)
            else:
                return visitor.visitChildren(self)




    def boundary_val(self):

        localctx = ABSParser.Boundary_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_boundary_val)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1478
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==94:
                self.state = 1477
                localctx.m = self.match(ABSParser.MINUS)


            self.state = 1480
            localctx.i = self.match(ABSParser.INTLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Main_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(ABSParser.AnnotationContext,i)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.StmtContext)
            else:
                return self.getTypedRuleContext(ABSParser.StmtContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_main_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMain_block" ):
                listener.enterMain_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMain_block" ):
                listener.exitMain_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMain_block" ):
                return visitor.visitMain_block(self)
            else:
                return visitor.visitChildren(self)




    def main_block(self):

        localctx = ABSParser.Main_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_main_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 1482
                self.annotation()
                self.state = 1487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1488
            self.match(ABSParser.T__18)
            self.state = 1492
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1073476333384) != 0) or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 127) != 0):
                self.state = 1489
                self.stmt()
                self.state = 1494
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1495
            self.match(ABSParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compilation_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def module_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Module_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Module_declContext,i)


        def delta_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Delta_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Delta_declContext,i)


        def update_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Update_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Update_declContext,i)


        def productline_decl(self):
            return self.getTypedRuleContext(ABSParser.Productline_declContext,0)


        def product_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Product_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Product_declContext,i)


        def feature_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.Feature_declContext)
            else:
                return self.getTypedRuleContext(ABSParser.Feature_declContext,i)


        def fextension(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ABSParser.FextensionContext)
            else:
                return self.getTypedRuleContext(ABSParser.FextensionContext,i)


        def getRuleIndex(self):
            return ABSParser.RULE_compilation_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilation_unit" ):
                listener.enterCompilation_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilation_unit" ):
                listener.exitCompilation_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilation_unit" ):
                return visitor.visitCompilation_unit(self)
            else:
                return visitor.visitChildren(self)




    def compilation_unit(self):

        localctx = ABSParser.Compilation_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_compilation_unit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1500
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==52:
                self.state = 1497
                self.module_decl()
                self.state = 1502
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1506
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 1503
                self.delta_decl()
                self.state = 1508
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1512
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==64:
                self.state = 1509
                self.update_decl()
                self.state = 1514
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1516
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 1515
                self.productline_decl()


            self.state = 1521
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==73:
                self.state = 1518
                self.product_decl()
                self.state = 1523
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==83 or _la==84:
                self.state = 1528
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [83]:
                    self.state = 1524
                    self.match(ABSParser.T__82)
                    self.state = 1525
                    self.feature_decl()
                    pass
                elif token in [84]:
                    self.state = 1526
                    self.match(ABSParser.T__83)
                    self.state = 1527
                    self.fextension()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1532
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GoalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compilation_unit(self):
            return self.getTypedRuleContext(ABSParser.Compilation_unitContext,0)


        def getRuleIndex(self):
            return ABSParser.RULE_goal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoal" ):
                listener.enterGoal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoal" ):
                listener.exitGoal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoal" ):
                return visitor.visitGoal(self)
            else:
                return visitor.visitChildren(self)




    def goal(self):

        localctx = ABSParser.GoalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_goal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1533
            self.compilation_unit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[11] = self.pure_exp_sempred
        self._predicates[19] = self.guard_sempred
        self._predicates[58] = self.application_condition_sempred
        self._predicates[68] = self.mexp_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def pure_exp_sempred(self, localctx:Pure_expContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 10)
         

    def guard_sempred(self, localctx:GuardContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         

    def application_condition_sempred(self, localctx:Application_conditionContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 3)
         

    def mexp_sempred(self, localctx:MexpContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 2)
         




